<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wayland protocol for graphics tablets"><title>wayland_protocols::wp::tablet - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wayland_protocols" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (7ac0330c6 2025-09-25)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module tablet</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../wayland_protocols/index.html">wayland_<wbr>protocols</a><span class="version">0.32.9</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module tablet</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In wayland_<wbr>protocols::<wbr>wp</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">wayland_protocols</a>::<wbr><a href="../index.html">wp</a></div><h1>Module <span>tablet</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/wayland_protocols/wp.rs.html#426">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wayland protocol for graphics tablets</p>
<p>This description provides a high-level overview of the interplay between
the interfaces defined this protocol. For details, see the protocol
specification.</p>
<p>More than one tablet may exist, and device-specifics matter. Tablets are
not represented by a single virtual device like wl_pointer. A client
binds to the tablet manager object which is just a proxy object. From
that, the client requests wp_tablet_manager.get_tablet_seat(wl_seat)
and that returns the actual interface that has all the tablets. With
this indirection, we can avoid merging wp_tablet into the actual Wayland
protocol, a long-term benefit.</p>
<p>The wp_tablet_seat sends a “tablet added” event for each tablet
connected. That event is followed by descriptive events about the
hardware; currently that includes events for name, vid/pid and
a wp_tablet.path event that describes a local path. This path can be
used to uniquely identify a tablet or get more information through
libwacom. Emulated or nested tablets can skip any of those, e.g. a
virtual tablet may not have a vid/pid. The sequence of descriptive
events is terminated by a wp_tablet.done event to signal that a client
may now finalize any initialization for that tablet.</p>
<p>Events from tablets require a tool in proximity. Tools are also managed
by the tablet seat; a “tool added” event is sent whenever a tool is new
to the compositor. That event is followed by a number of descriptive
events about the hardware; currently that includes capabilities,
hardware id and serial number, and tool type. Similar to the tablet
interface, a wp_tablet_tool.done event is sent to terminate that initial
sequence.</p>
<p>Any event from a tool happens on the wp_tablet_tool interface. When the
tool gets into proximity of the tablet, a proximity_in event is sent on
the wp_tablet_tool interface, listing the tablet and the surface. That
event is followed by a motion event with the coordinates. After that,
it’s the usual motion, axis, button, etc. events. The protocol’s
serialisation means events are grouped by wp_tablet_tool.frame events.</p>
<p>Two special events (that don’t exist in X) are down and up. They signal
“tip touching the surface”. For tablets without real proximity
detection, the sequence is: proximity_in, motion, down, frame.</p>
<p>When the tool leaves proximity, a proximity_out event is sent. If any
button is still down, a button release event is sent before this
proximity event. These button events are sent in the same frame as the
proximity event to signal to the client that the buttons were held when
the tool left proximity.</p>
<p>If the tool moves out of the surface but stays in proximity (i.e.
between windows), compositor-specific grab policies apply. This usually
means that the proximity-out is delayed until all buttons are released.</p>
<p>Moving a tool physically from one tablet to the other has no real effect
on the protocol, since we already have the tool object from the “tool
added” event. All the information is already there and the proximity
events on both tablets are all a client needs to reconstruct what
happened.</p>
<p>Some extra axes are normalized, i.e. the client knows the range as
specified in the protocol (e.g. [0, 65535]), the granularity however is
unknown. The current normalized axes are pressure, distance, and slider.</p>
<p>Other extra axes are in physical units as specified in the protocol.
The current extra axes with physical units are tilt, rotation and
wheel rotation.</p>
<p>Since tablets work independently of the pointer controlled by the mouse,
the focus handling is independent too and controlled by proximity.
The wp_tablet_tool.set_cursor request sets a tool-specific cursor.
This cursor surface may be the same as the mouse cursor, and it may be
the same across tools but it is possible to be more fine-grained. For
example, a client may set different cursors for the pen and eraser.</p>
<p>Tools are generally independent of tablets and it is
compositor-specific policy when a tool can be removed. Common approaches
will likely include some form of removing a tool when all tablets the
tool was used on are removed.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="zv1/index.html" title="mod wayland_protocols::wp::tablet::zv1">zv1</a></dt><dd>Unstable version 1</dd><dt><a class="mod" href="zv2/index.html" title="mod wayland_protocols::wp::tablet::zv2">zv2</a></dt><dd>Unstable version 2</dd></dl></section></div></main></body></html>