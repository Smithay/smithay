<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="desktop user interface surface base interface"><title>wayland_protocols::xdg::shell::server::xdg_surface - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="wayland_protocols" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (7ac0330c6 2025-09-25)" data-channel="nightly" data-search-js="search-e256b49e.js" data-stringdex-js="stringdex-061df703.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module xdg_surface</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../wayland_protocols/index.html">wayland_<wbr>protocols</a><span class="version">0.32.9</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module xdg_<wbr>surface</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In wayland_<wbr>protocols::<wbr>xdg::<wbr>shell::<wbr>server</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../index.html">wayland_protocols</a>::<wbr><a href="../../../index.html">xdg</a>::<wbr><a href="../../index.html">shell</a>::<wbr><a href="../index.html">server</a></div><h1>Module <span>xdg_<wbr>surface</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../../../src/wayland_protocols/xdg.rs.html#138-141">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>server</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>desktop user interface surface base interface</p>
<p>An interface that may be implemented by a wl_surface, for
implementations that provide a desktop-style user interface.</p>
<p>It provides a base set of functionality required to construct user
interface elements requiring management by the compositor, such as
toplevel windows, menus, etc. The types of functionality are split into
xdg_surface roles.</p>
<p>Creating an xdg_surface does not set the role for a wl_surface. In order
to map an xdg_surface, the client must create a role-specific object
using, e.g., get_toplevel, get_popup. The wl_surface for any given
xdg_surface can have at most one role, and may not be assigned any role
not based on xdg_surface.</p>
<p>A role must be assigned before any other requests are made to the
xdg_surface object.</p>
<p>The client must call wl_surface.commit on the corresponding wl_surface
for the xdg_surface state to take effect.</p>
<p>Creating an xdg_surface from a wl_surface which has a buffer attached or
committed is a client error, and any attempts by a client to attach or
manipulate a buffer prior to the first xdg_surface.configure call must
also be treated as errors.</p>
<p>After creating a role-specific object and setting it up (e.g. by sending
the title, app ID, size constraints, parent, etc), the client must
perform an initial commit without any buffer attached. The compositor
will reply with initial wl_surface state such as
wl_surface.preferred_buffer_scale followed by an xdg_surface.configure
event. The client must acknowledge it and is then allowed to attach a
buffer to map the surface.</p>
<p>Mapping an xdg_surface-based role surface is defined as making it
possible for the surface to be shown by the compositor. Note that
a mapped surface is not guaranteed to be visible once it is mapped.</p>
<p>For an xdg_surface to be mapped by the compositor, the following
conditions must be met:
(1) the client has assigned an xdg_surface-based role to the surface
(2) the client has set and committed the xdg_surface state and the
role-dependent state to the surface
(3) the client has committed a buffer to the surface</p>
<p>A newly-unmapped surface is considered to have met condition (1) out
of the 3 required conditions for mapping a surface if its role surface
has not been destroyed, i.e. the client must perform the initial commit
again before attaching a buffer.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.XdgSurface.html" title="struct wayland_protocols::xdg::shell::server::xdg_surface::XdgSurface">XdgSurface</a></dt><dd>desktop user interface surface base interface</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum wayland_protocols::xdg::shell::server::xdg_surface::Error">Error</a></dt><dt><a class="enum" href="enum.Event.html" title="enum wayland_protocols::xdg::shell::server::xdg_surface::Event">Event</a></dt><dt><a class="enum" href="enum.Request.html" title="enum wayland_protocols::xdg::shell::server::xdg_surface::Request">Request</a></dt></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="constant" href="constant.EVT_CONFIGURE_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::EVT_CONFIGURE_OPCODE">EVT_<wbr>CONFIGURE_<wbr>OPCODE</a></dt><dd>The wire opcode for this event</dd><dt><a class="constant" href="constant.EVT_CONFIGURE_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::EVT_CONFIGURE_SINCE">EVT_<wbr>CONFIGURE_<wbr>SINCE</a></dt><dd>The minimal object version supporting this event</dd><dt><a class="constant" href="constant.REQ_ACK_CONFIGURE_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_ACK_CONFIGURE_OPCODE">REQ_<wbr>ACK_<wbr>CONFIGURE_<wbr>OPCODE</a></dt><dd>The wire opcode for this request</dd><dt><a class="constant" href="constant.REQ_ACK_CONFIGURE_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_ACK_CONFIGURE_SINCE">REQ_<wbr>ACK_<wbr>CONFIGURE_<wbr>SINCE</a></dt><dd>The minimal object version supporting this request</dd><dt><a class="constant" href="constant.REQ_DESTROY_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_DESTROY_OPCODE">REQ_<wbr>DESTROY_<wbr>OPCODE</a></dt><dd>The wire opcode for this request</dd><dt><a class="constant" href="constant.REQ_DESTROY_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_DESTROY_SINCE">REQ_<wbr>DESTROY_<wbr>SINCE</a></dt><dd>The minimal object version supporting this request</dd><dt><a class="constant" href="constant.REQ_GET_POPUP_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_GET_POPUP_OPCODE">REQ_<wbr>GET_<wbr>POPUP_<wbr>OPCODE</a></dt><dd>The wire opcode for this request</dd><dt><a class="constant" href="constant.REQ_GET_POPUP_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_GET_POPUP_SINCE">REQ_<wbr>GET_<wbr>POPUP_<wbr>SINCE</a></dt><dd>The minimal object version supporting this request</dd><dt><a class="constant" href="constant.REQ_GET_TOPLEVEL_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_GET_TOPLEVEL_OPCODE">REQ_<wbr>GET_<wbr>TOPLEVEL_<wbr>OPCODE</a></dt><dd>The wire opcode for this request</dd><dt><a class="constant" href="constant.REQ_GET_TOPLEVEL_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_GET_TOPLEVEL_SINCE">REQ_<wbr>GET_<wbr>TOPLEVEL_<wbr>SINCE</a></dt><dd>The minimal object version supporting this request</dd><dt><a class="constant" href="constant.REQ_SET_WINDOW_GEOMETRY_OPCODE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_SET_WINDOW_GEOMETRY_OPCODE">REQ_<wbr>SET_<wbr>WINDOW_<wbr>GEOMETRY_<wbr>OPCODE</a></dt><dd>The wire opcode for this request</dd><dt><a class="constant" href="constant.REQ_SET_WINDOW_GEOMETRY_SINCE.html" title="constant wayland_protocols::xdg::shell::server::xdg_surface::REQ_SET_WINDOW_GEOMETRY_SINCE">REQ_<wbr>SET_<wbr>WINDOW_<wbr>GEOMETRY_<wbr>SINCE</a></dt><dd>The minimal object version supporting this request</dd></dl></section></div></main></body></html>