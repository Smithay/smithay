(function() {
    var type_impls = Object.fromEntries([["smithay",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#694\">Source</a></span><a href=\"#impl-Debug-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#695\">Source</a><a href=\"#method.fmt\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Default-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.10.0\">1.10.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#686\">Source</a></span><a href=\"#impl-Default-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html\" title=\"trait core::default::Default\">Default</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.default\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#688\">Source</a><a href=\"#method.default\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/default/trait.Default.html#tymethod.default\" class=\"fn\">default</a>() -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a <code>Mutex&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>\n</div></details></div></details>","Default","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-From%3CT%3E-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.24.0\">1.24.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#677\">Source</a></span><a href=\"#impl-From%3CT%3E-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/convert/trait.From.html\" title=\"trait core::convert::From\">From</a>&lt;T&gt; for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.from\" class=\"method trait-impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#680\">Source</a><a href=\"#method.from\" class=\"anchor\">Â§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from\" class=\"fn\">from</a>(t: T) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new mutex in an unlocked state ready for use.\nThis is equivalent to <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#method.new\" title=\"associated function std::sync::poison::mutex::Mutex::new\"><code>Mutex::new</code></a>.</p>\n</div></details></div></details>","From<T>","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Mutex%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#337\">Source</a><a href=\"#impl-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0, const since 1.63.0\">1.0.0 (const: 1.63.0)</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#350\">Source</a></span><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.new\" class=\"fn\">new</a>(t: T) -&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new mutex in an unlocked state ready for use.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span>mutex = Mutex::new(<span class=\"number\">0</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_cloned\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#373-375\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.get_cloned\" class=\"fn\">get_cloned</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>&gt;&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,</div></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns the contained value by cloning it.</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error instead.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(lock_value_accessors)]\n\n</span><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>mutex = Mutex::new(<span class=\"number\">7</span>);\n\n<span class=\"macro\">assert_eq!</span>(mutex.get_cloned().unwrap(), <span class=\"number\">7</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.set\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#404\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.set\" class=\"fn\">set</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>)</span></div></span></summary><div class=\"docblock\"><p>Sets the contained value.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error containing the provided <code>value</code> instead.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(lock_value_accessors)]\n\n</span><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>mutex = Mutex::new(<span class=\"number\">7</span>);\n\n<span class=\"macro\">assert_eq!</span>(mutex.get_cloned().unwrap(), <span class=\"number\">7</span>);\nmutex.set(<span class=\"number\">11</span>).unwrap();\n<span class=\"macro\">assert_eq!</span>(mutex.get_cloned().unwrap(), <span class=\"number\">11</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.replace\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#441\">Source</a><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.replace\" class=\"fn\">replace</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;T&gt;&gt;</h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>)</span></div></span></summary><div class=\"docblock\"><p>Replaces the contained value with <code>value</code>, and returns the old contained value.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error containing the provided <code>value</code> instead.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"attr\">#![feature(lock_value_accessors)]\n\n</span><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>mutex = Mutex::new(<span class=\"number\">7</span>);\n\n<span class=\"macro\">assert_eq!</span>(mutex.replace(<span class=\"number\">11</span>).unwrap(), <span class=\"number\">7</span>);\n<span class=\"macro\">assert_eq!</span>(mutex.get_cloned().unwrap(), <span class=\"number\">11</span>);</code></pre></div></div></details></div></details>",0,"smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Mutex%3CT%3E\" class=\"impl\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#449\">Source</a><a href=\"#impl-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.lock\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#487\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.lock\" class=\"fn\">lock</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.MutexGuard.html\" title=\"struct std::sync::poison::mutex::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.MutexGuard.html\" title=\"struct std::sync::poison::mutex::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Acquires a mutex, blocking the current thread until it is able to do so.</p>\n<p>This function will block the local thread until it is available to acquire\nthe mutex. Upon returning, the thread is the only thread with the lock\nheld. An RAII guard is returned to allow scoped unlock of the lock. When\nthe guard goes out of scope, the mutex will be unlocked.</p>\n<p>The exact behavior on locking a mutex in the thread which already holds\nthe lock is left unspecified. However, this function will not return on\nthe second call (it might panic or deadlock, for example).</p>\n<h5 id=\"errors\"><a class=\"doc-anchor\" href=\"#errors\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error once the mutex is acquired. The acquired\nmutex guard will be contained in the returned error.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">Â§</a>Panics</h5>\n<p>This function might panic when called if the lock is already held by\nthe current thread.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\nthread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw-2\">*</span>c_mutex.lock().unwrap() = <span class=\"number\">10</span>;\n}).join().expect(<span class=\"string\">\"thread::spawn failed\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.try_lock\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#535\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.try_lock\" class=\"fn\">try_lock</a>(\n    &amp;self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.MutexGuard.html\" title=\"struct std::sync::poison::mutex::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;, <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/enum.TryLockError.html\" title=\"enum std::sync::poison::TryLockError\">TryLockError</a>&lt;<a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.MutexGuard.html\" title=\"struct std::sync::poison::mutex::MutexGuard\">MutexGuard</a>&lt;'_, T&gt;&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Attempts to acquire this lock.</p>\n<p>If the lock could not be acquired at this time, then <a href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html#variant.Err\" title=\"variant core::result::Result::Err\"><code>Err</code></a> is returned.\nOtherwise, an RAII guard is returned. The lock will be unlocked when the\nguard is dropped.</p>\n<p>This function does not block.</p>\n<h5 id=\"errors-1\"><a class=\"doc-anchor\" href=\"#errors-1\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return the <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/enum.TryLockError.html#variant.Poisoned\" title=\"variant std::sync::poison::TryLockError::Poisoned\"><code>Poisoned</code></a> error if the mutex would\notherwise be acquired. An acquired lock guard will be contained\nin the returned error.</p>\n<p>If the mutex could not be acquired because it is already locked, then\nthis call will return the <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/enum.TryLockError.html#variant.WouldBlock\" title=\"variant std::sync::poison::TryLockError::WouldBlock\"><code>WouldBlock</code></a> error.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\nthread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>lock = c_mutex.try_lock();\n    <span class=\"kw\">if let </span><span class=\"prelude-val\">Ok</span>(<span class=\"kw-2\">ref mut </span>mutex) = lock {\n        <span class=\"kw-2\">**</span>mutex = <span class=\"number\">10</span>;\n    } <span class=\"kw\">else </span>{\n        <span class=\"macro\">println!</span>(<span class=\"string\">\"try_lock failed\"</span>);\n    }\n}).join().expect(<span class=\"string\">\"thread::spawn failed\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_poisoned\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.2.0\">1.2.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#568\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.is_poisoned\" class=\"fn\">is_poisoned</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Determines whether the mutex is poisoned.</p>\n<p>If another thread is active, the mutex can still become poisoned at any\ntime. You should not trust a <code>false</code> value for program correctness\nwithout additional synchronization.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\n<span class=\"kw\">let _ </span>= thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span>_lock = c_mutex.lock().unwrap();\n    <span class=\"macro\">panic!</span>(); <span class=\"comment\">// the mutex gets poisoned\n</span>}).join();\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">true</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clear_poison\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.77.0\">1.77.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#605\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.clear_poison\" class=\"fn\">clear_poison</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Clear the poisoned state from a mutex.</p>\n<p>If the mutex is poisoned, it will remain poisoned until this function is called. This\nallows recovering from a poisoned state and marking that it has recovered. For example, if\nthe value is overwritten by a known-good value, then the mutex can be marked as\nun-poisoned. Or possibly, the value could be inspected to determine if it is in a\nconsistent state, and if so the poison is removed.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::{Arc, Mutex};\n<span class=\"kw\">use </span>std::thread;\n\n<span class=\"kw\">let </span>mutex = Arc::new(Mutex::new(<span class=\"number\">0</span>));\n<span class=\"kw\">let </span>c_mutex = Arc::clone(<span class=\"kw-2\">&amp;</span>mutex);\n\n<span class=\"kw\">let _ </span>= thread::spawn(<span class=\"kw\">move </span>|| {\n    <span class=\"kw\">let </span>_lock = c_mutex.lock().unwrap();\n    <span class=\"macro\">panic!</span>(); <span class=\"comment\">// the mutex gets poisoned\n</span>}).join();\n\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">true</span>);\n<span class=\"kw\">let </span>x = mutex.lock().unwrap_or_else(|<span class=\"kw-2\">mut </span>e| {\n    <span class=\"kw-2\">**</span>e.get_mut() = <span class=\"number\">1</span>;\n    mutex.clear_poison();\n    e.into_inner()\n});\n<span class=\"macro\">assert_eq!</span>(mutex.is_poisoned(), <span class=\"bool-val\">false</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>x, <span class=\"number\">1</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_inner\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#626-628\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.into_inner\" class=\"fn\">into_inner</a>(self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;T, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Consumes this mutex, returning the underlying data.</p>\n<h5 id=\"errors-2\"><a class=\"doc-anchor\" href=\"#errors-2\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error containing the underlying data\ninstead.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span>mutex = Mutex::new(<span class=\"number\">0</span>);\n<span class=\"macro\">assert_eq!</span>(mutex.into_inner().unwrap(), <span class=\"number\">0</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.get_mut\" class=\"method\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.6.0\">1.6.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#659\">Source</a></span><h4 class=\"code-header\">pub fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.get_mut\" class=\"fn\">get_mut</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/nightly/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;mut T</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/struct.PoisonError.html\" title=\"struct std::sync::poison::PoisonError\">PoisonError</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.reference.html\">&amp;mut T</a>&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a mutable reference to the underlying data.</p>\n<p>Since this call borrows the <code>Mutex</code> mutably, no actual locking needs to\ntake place â€“ the mutable borrow statically guarantees no new locks can be acquired\nwhile this reference exists. Note that this method does not clear any previous abandoned locks\n(e.g., via <a href=\"https://doc.rust-lang.org/nightly/core/mem/fn.forget.html\" title=\"fn core::mem::forget\"><code>forget()</code></a> on a <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.MutexGuard.html\" title=\"struct std::sync::poison::mutex::MutexGuard\"><code>MutexGuard</code></a>).</p>\n<h5 id=\"errors-3\"><a class=\"doc-anchor\" href=\"#errors-3\">Â§</a>Errors</h5>\n<p>If another user of this mutex panicked while holding the mutex, then\nthis call will return an error containing a mutable reference to the\nunderlying data instead.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">Â§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>std::sync::Mutex;\n\n<span class=\"kw\">let </span><span class=\"kw-2\">mut </span>mutex = Mutex::new(<span class=\"number\">0</span>);\n<span class=\"kw-2\">*</span>mutex.get_mut().unwrap() = <span class=\"number\">10</span>;\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>mutex.lock().unwrap(), <span class=\"number\">10</span>);</code></pre></div></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.data_ptr\" class=\"method\"><a class=\"src rightside\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#671\">Source</a><h4 class=\"code-header\">pub const fn <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#tymethod.data_ptr\" class=\"fn\">data_ptr</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.pointer.html\">*mut T</a></h4></section><span class=\"item-info\"><div class=\"stab unstable\"><span class=\"emoji\">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>mutex_data_ptr</code>)</span></div></span></summary><div class=\"docblock\"><p>Returns a raw pointer to the underlying data.</p>\n<p>The returned pointer is always non-null and properly aligned, but it is\nthe userâ€™s responsibility to ensure that any reads and writes through it\nare properly synchronized to avoid data races, and that it is not read\nor written through after the mutex is dropped.</p>\n</div></details></div></details>",0,"smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<section id=\"impl-RefUnwindSafe-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.12.0\">1.12.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/panic.rs.html#271\">Source</a></span><a href=\"#impl-RefUnwindSafe-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html\" title=\"trait core::panic::unwind_safe::RefUnwindSafe\">RefUnwindSafe</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3></section>","RefUnwindSafe","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<section id=\"impl-Send-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#238\">Source</a></span><a href=\"#impl-Send-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3><div class=\"docblock\"><p><code>T</code> must be <code>Send</code> for a <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\"><code>Mutex</code></a> to be <code>Send</code> because it is possible to acquire\nthe owned <code>T</code> from the <code>Mutex</code> via <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html#method.into_inner\" title=\"method std::sync::poison::mutex::Mutex::into_inner\"><code>into_inner</code></a>.</p>\n</div></section>","Send","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<section id=\"impl-Sync-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/sync/poison/mutex.rs.html#257\">Source</a></span><a href=\"#impl-Sync-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html\" title=\"trait core::marker::Sync\">Sync</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Send.html\" title=\"trait core::marker::Send\">Send</a> + ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3><div class=\"docblock\"><p><code>T</code> must be <code>Send</code> for <a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\"><code>Mutex</code></a> to be <code>Sync</code>.\nThis ensures that the protected data can be accessed safely from multiple threads\nwithout causing data races or other unsafe behavior.</p>\n</div></section><div class=\"docblock\"><p><a href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\"><code>Mutex&lt;T&gt;</code></a> provides mutable access to <code>T</code> to one thread at a time. However, itâ€™s essential\nfor <code>T</code> to be <code>Send</code> because itâ€™s not safe for non-<code>Send</code> structures to be accessed in\nthis manner. For instance, consider <a href=\"https://doc.rust-lang.org/nightly/alloc/rc/struct.Rc.html\" title=\"struct alloc::rc::Rc\"><code>Rc</code></a>, a non-atomic reference counted smart pointer,\nwhich is not <code>Send</code>. With <code>Rc</code>, we can have multiple copies pointing to the same heap\nallocation with a non-atomic reference count. If we were to use <code>Mutex&lt;Rc&lt;_&gt;&gt;</code>, it would\nonly protect one instance of <code>Rc</code> from shared access, leaving other copies vulnerable\nto potential data races.</p>\n<p>Also note that it is not necessary for <code>T</code> to be <code>Sync</code> as <code>&amp;T</code> is only made available\nto one thread at a time if <code>T</code> is not <code>Sync</code>.</p>\n</div>","Sync","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"],["<section id=\"impl-UnwindSafe-for-Mutex%3CT%3E\" class=\"impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.9.0\">1.9.0</span> Â· <a class=\"src\" href=\"https://doc.rust-lang.org/nightly/src/std/panic.rs.html#264\">Source</a></span><a href=\"#impl-UnwindSafe-for-Mutex%3CT%3E\" class=\"anchor\">Â§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html\" title=\"trait core::panic::unwind_safe::UnwindSafe\">UnwindSafe</a> for <a class=\"struct\" href=\"https://doc.rust-lang.org/nightly/std/sync/poison/mutex/struct.Mutex.html\" title=\"struct std::sync::poison::mutex::Mutex\">Mutex</a>&lt;T&gt;<div class=\"where\">where\n    T: ?<a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html\" title=\"trait core::marker::Sized\">Sized</a>,</div></h3></section>","UnwindSafe","smithay::backend::renderer::utils::wayland::RendererSurfaceStateUserData","smithay::input::pointer::cursor_image::CursorImageSurfaceData","smithay::wayland::commit_timing::CommitTimerBarrierStateUserData","smithay::wayland::session_lock::surface::LockSurfaceData","smithay::wayland::shell::wlr_layer::LayerSurfaceData","smithay::wayland::shell::xdg::XdgToplevelSurfaceData","smithay::wayland::shell::xdg::XdgPopupSurfaceData"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[40590]}