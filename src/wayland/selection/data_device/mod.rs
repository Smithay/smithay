//! Utilities for manipulating the data devices
//!
//! The data device is wayland's abstraction to represent both selection (copy/paste) and
//! drag'n'drop actions. This module provides logic to handle this part of the protocol.
//! Selection and drag'n'drop are per-seat notions.
//!
//! This module provides the freestanding [`set_data_device_focus`] function:
//!   This function sets the data device focus for a given seat; you'd typically call it
//!   whenever the keyboard focus changes, to follow it (for example in the focus hook of your keyboards).
//!
//! Using these two functions is enough for your clients to be able to interact with each other using
//! the data devices.
//!
//! The module also provides additional mechanisms allowing your compositor to see and interact with
//! the contents of the data device:
//!
//! - the freestanding function [`set_data_device_selection`]
//!   allows you to set the contents of the selection for your clients
//!
//! The module defines the role `"dnd_icon"` that is assigned to surfaces used as drag'n'drop icons.
//!
//! ## Initialization
//!
//! To initialize this implementation, create the [`DataDeviceState`], store it inside your `State` struct
//! and implement the [`DataDeviceHandler`] and [`SelectionHandler`], as shown in this example:
//!
//! ```
//! # extern crate wayland_server;
//! # #[macro_use] extern crate smithay;
//! use smithay::delegate_data_device;
//! use smithay::wayland::selection::SelectionHandler;
//! use smithay::wayland::selection::data_device::{WaylandDndGrabHandler, DataDeviceState, DataDeviceHandler};
//! # use smithay::input::{Seat, SeatState, SeatHandler, pointer::CursorImageStatus};
//! # use smithay::reexports::wayland_server::protocol::wl_surface::WlSurface;
//!
//! # struct State { data_device_state: DataDeviceState }
//! # let mut display = wayland_server::Display::<State>::new().unwrap();
//! // Create the data_device state
//! let data_device_state = DataDeviceState::new::<State>(
//!     &display.handle(),
//! );
//!
//! // insert the DataDeviceState into your state
//! // ..
//!
//! // implement the necessary traits
//! # impl SeatHandler for State {
//! #     type KeyboardFocus = WlSurface;
//! #     type PointerFocus = WlSurface;
//! #     type TouchFocus = WlSurface;
//! #     fn seat_state(&mut self) -> &mut SeatState<Self> { unimplemented!() }
//! #     fn focus_changed(&mut self, seat: &Seat<Self>, focused: Option<&WlSurface>) { unimplemented!() }
//! #     fn cursor_image(&mut self, seat: &Seat<Self>, image: CursorImageStatus) { unimplemented!() }
//! # }
//! impl WaylandDndGrabHandler for State {
//!     // ... implement `dnd_requested` to handle drag&drop operations
//! }
//! impl SelectionHandler for State {
//!     type SelectionUserData = ();
//! }
//! impl DataDeviceHandler for State {
//!     fn data_device_state(&mut self) -> &mut DataDeviceState { &mut self.data_device_state }
//!     // ... override default implementations here to customize handling ...
//! }
//! delegate_data_device!(State);
//!
//! // You're now ready to go!
//! ```

use std::{
    cell::{Ref, RefCell},
    collections::HashMap,
    os::unix::io::OwnedFd,
    sync::{Arc, Mutex},
};

use smallvec::SmallVec;
use tracing::instrument;
use wayland_server::{
    backend::{protocol::Message, ClientId, GlobalId, Handle, ObjectData, ObjectId},
    protocol::{
        wl_data_device_manager::{DndAction as WlDndAction, WlDataDeviceManager},
        wl_data_offer::{self, WlDataOffer},
        wl_data_source::WlDataSource,
        wl_seat::WlSeat,
        wl_surface::WlSurface,
    },
    Client, DisplayHandle, GlobalDispatch, Resource,
};

use crate::{
    input::{
        dnd::{DndAction, DndFocus, GrabType, OfferData, Source},
        Seat, SeatHandler,
    },
    utils::{Logical, Point, Serial},
};

mod device;
mod source;

pub use device::{DataDeviceUserData, DND_ICON_ROLE};
pub use source::DataSourceUserData;

use super::{
    offer::OfferReplySource, seat_data::SeatData, source::CompositorSelectionProvider, SelectionHandler,
    SelectionTarget,
};

/// Events that are generated by interactions of the clients with the data device
#[allow(unused_variables)]
pub trait DataDeviceHandler: Sized + SelectionHandler + WaylandDndGrabHandler {
    /// [DataDeviceState] getter
    fn data_device_state(&mut self) -> &mut DataDeviceState;

    /// Action chooser for DnD negociation
    fn action_choice(&mut self, available: WlDndAction, preferred: WlDndAction) -> WlDndAction {
        default_action_chooser(available, preferred)
    }
}

/// Handler for wayland client initiated drag'n'drop
#[allow(unused_variables)]
pub trait WaylandDndGrabHandler: SeatHandler + Sized {
    /// A client requested a drag'n'drop as response to a user pointer action
    ///
    /// * `source` - The data source provided by the client.
    /// * `icon` - The icon the client requested to be used to be associated with the cursor icon
    ///   during the drag'n'drop.
    /// * `seat` - The seat on which the DnD operation was started
    /// * `serial` - Serial passed and validated for the grab
    /// * `type_` - If the grab was validated for pointer or touch input
    fn dnd_requested<S: Source>(
        &mut self,
        source: S,
        icon: Option<WlSurface>,
        seat: Seat<Self>,
        serial: Serial,
        type_: GrabType,
    ) {
        source.cancel();
        let _ = (icon, seat, type_);
    }
}

impl DndAction {
    fn unwrap_single(slice: &[Self]) -> Option<Self> {
        if slice.is_empty() {
            Some(Self::None)
        } else if slice.len() == 1 {
            Some(slice[0])
        } else {
            None
        }
    }

    fn vec_from_wl(value: WlDndAction) -> SmallVec<[Self; 3]> {
        let mut vec = SmallVec::new();
        if value.contains(WlDndAction::Ask) {
            vec.push(Self::Ask);
        }
        if value.contains(WlDndAction::Copy) {
            vec.push(Self::Copy);
        }
        if value.contains(WlDndAction::Move) {
            vec.push(Self::Move);
        }
        vec
    }

    fn convert_slice(value: &[Self]) -> WlDndAction {
        let mut result = WlDndAction::None;
        for action in value.iter().copied() {
            result |= action.into();
        }
        result
    }
}

impl From<DndAction> for WlDndAction {
    fn from(value: DndAction) -> Self {
        match value {
            DndAction::Ask => WlDndAction::Ask,
            DndAction::Copy => WlDndAction::Copy,
            DndAction::Move => WlDndAction::Move,
            _ => WlDndAction::None,
        }
    }
}

#[derive(Debug)]
struct WlOfferState {
    active: bool,
    dropped: bool,
    accepted: bool,
    finished: bool,
    chosen_action: WlDndAction,
}

struct WlDndDataOffer<S: Source> {
    state: Arc<Mutex<WlOfferState>>,
    source: Mutex<Option<Arc<S>>>,
}

impl<D, S> ObjectData<D> for WlDndDataOffer<S>
where
    D: DataDeviceHandler,
    D: 'static,
    S: Source,
{
    fn request(
        self: Arc<Self>,
        dh: &Handle,
        handler: &mut D,
        _client_id: ClientId,
        msg: Message<ObjectId, OwnedFd>,
    ) -> Option<Arc<dyn ObjectData<D>>> {
        let dh = DisplayHandle::from(dh.clone());
        if let Ok((resource, request)) = WlDataOffer::parse_request(&dh, msg) {
            handle_dnd(handler, &resource, request, &self);
        }

        None
    }

    fn destroyed(
        self: Arc<Self>,
        _handle: &Handle,
        _data: &mut D,
        _client_id: ClientId,
        _object_id: ObjectId,
    ) {
    }
}

fn handle_dnd<D, S>(
    handler: &mut D,
    offer: &WlDataOffer,
    request: wl_data_offer::Request,
    data: &WlDndDataOffer<S>,
) where
    D: DataDeviceHandler,
    D: 'static,
    S: Source,
{
    use self::wl_data_offer::Request;
    let mut source = data.source.lock().unwrap();
    let mut data = data.state.lock().unwrap();
    match request {
        Request::Accept { mime_type, .. } => {
            if let Some(source) = source.as_ref() {
                if let Some(mtype) = mime_type {
                    data.accepted = source
                        .metadata()
                        .is_some_and(|meta| meta.mime_types.contains(&mtype));
                } else {
                    data.accepted = false;
                }
            } else if data.finished {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Accept request after Finish.",
                );
            }
        }
        Request::Receive { mime_type, fd } => {
            if let Some(source) = source.as_ref() {
                // check if the source and associated mime type is still valid
                let valid = source
                    .metadata()
                    .is_some_and(|meta| meta.mime_types.contains(&mime_type))
                    && source.alive()
                    && data.active;
                if valid {
                    source.send(&mime_type, fd);
                }
            } else if data.finished {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Receive request after Finish.",
                );
            }
        }
        Request::Destroy => {
            if data.dropped && !data.finished {
                if let Some(source) = source.as_ref() {
                    source.cancel();
                }
            }
        }
        Request::Finish => {
            if !data.active {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Cannot finish a data offer that is no longer active.",
                );
                return;
            }
            if !data.accepted {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Cannot finish a data offer that has not been accepted.",
                );
                return;
            }
            if !data.dropped {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Cannot finish a data offer that has not been dropped.",
                );
                return;
            }
            if data.chosen_action.is_empty() {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Cannot finish a data offer with no valid action.",
                );
                return;
            }
            if let Some(source) = source.take() {
                source.finished();
            } else if data.finished {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "Cannot finish a data offer, which was finished already.",
                );
            }
            data.active = false;
            data.finished = true;
        }
        Request::SetActions {
            dnd_actions,
            preferred_action,
        } => {
            if let Some(source) = source.as_ref() {
                let dnd_actions = dnd_actions.into_result().unwrap_or(WlDndAction::None);
                let preferred_action = preferred_action.into_result().unwrap_or(WlDndAction::None);

                // preferred_action must only contain one bitflag at the same time
                if ![
                    WlDndAction::None,
                    WlDndAction::Move,
                    WlDndAction::Copy,
                    WlDndAction::Ask,
                ]
                .contains(&preferred_action)
                {
                    offer.post_error(wl_data_offer::Error::InvalidAction, "Invalid preferred action.");
                    return;
                }

                let source_actions = source
                    .metadata()
                    .map(|meta| DndAction::convert_slice(&meta.dnd_actions))
                    .unwrap_or_else(WlDndAction::empty);
                let possible_actions = source_actions & dnd_actions;
                let chosen_action = handler.action_choice(possible_actions, preferred_action);
                // check that the user provided callback respects that one precise action should be chosen
                debug_assert!(
                    [
                        WlDndAction::None,
                        WlDndAction::Move,
                        WlDndAction::Copy,
                        WlDndAction::Ask
                    ]
                    .contains(&chosen_action),
                    "Only one precise action should be chosen"
                );
                if chosen_action != data.chosen_action {
                    data.chosen_action = chosen_action;
                    offer.action(chosen_action);
                    source.choose_action(
                        DndAction::unwrap_single(&DndAction::vec_from_wl(chosen_action))
                            .expect("We have selected a single value at this point."),
                    );
                }
            } else if data.finished {
                offer.post_error(
                    wl_data_offer::Error::InvalidFinish,
                    "SetActions request after Finish.",
                );
            }
        }
        _ => unreachable!(),
    }
}

/// Type implementing [`OfferData`] for wl_data_offer based DnD sources
#[derive(Debug)]
pub struct WlOfferData<S: Source> {
    state: Arc<Mutex<WlOfferState>>,
    source: Arc<S>,
    last_source_actions: SmallVec<[DndAction; 3]>,
    #[allow(dead_code)]
    wl_offers: Vec<wl_data_offer::WlDataOffer>,
}

impl<S: Source> OfferData for WlOfferData<S> {
    fn disable(&self) {
        self.state.lock().unwrap().active = false;
        self.source.choose_action(DndAction::None);
        for offer in &self.wl_offers {
            if let Some(data) = offer
                .object_data()
                .and_then(|arc| arc.downcast_ref::<WlDndDataOffer<S>>())
            {
                data.source.lock().unwrap().take();
            }
        }
    }

    fn drop(&self) {
        self.state.lock().unwrap().dropped = true;
    }

    fn validated(&self) -> bool {
        let data = self.state.lock().unwrap();
        data.accepted
    }
}

impl<D: SeatHandler + DataDeviceHandler + 'static> DndFocus<D> for WlSurface {
    type OfferData<S: Source> = WlOfferData<S>;

    fn enter<S: Source>(
        &self,
        _data: &mut D,
        dh: &DisplayHandle,
        source: Arc<S>,
        seat: &Seat<D>,
        location: Point<f64, Logical>,
        serial: &Serial,
    ) -> Option<Self::OfferData<S>> {
        let seat_data = seat
            .user_data()
            .get::<RefCell<SeatData<D::SelectionUserData>>>()
            .unwrap()
            .borrow();
        let mut offers = Vec::with_capacity(1);
        let offer_state = Arc::new(Mutex::new(WlOfferState {
            active: true,
            dropped: false,
            accepted: true,
            finished: false,
            chosen_action: WlDndAction::empty(),
        }));

        if source.is_client_local(self) {
            for device in seat_data
                .known_data_devices()
                .filter(|d| d.id().same_client_as(&self.id()))
            {
                device.enter((*serial).into(), self, location.x, location.y, None);
            }
            None
        } else if let Some(metadata) = source.metadata() {
            let handle = dh.backend_handle();
            let client = handle.get_client(self.id()).ok()?;

            for device in seat_data
                .known_data_devices()
                .filter(|d| d.id().same_client_as(&self.id()))
            {
                // create a data offer
                let offer = handle
                    .create_object::<D>(
                        client.clone(),
                        WlDataOffer::interface(),
                        device.version(),
                        Arc::new(WlDndDataOffer {
                            state: offer_state.clone(),
                            source: Mutex::new(Some(source.clone())),
                        }),
                    )
                    .unwrap();
                let offer = WlDataOffer::from_id(dh, offer).unwrap();

                // advertize the offer to the client
                device.data_offer(&offer);

                for mime_type in metadata.mime_types.iter().cloned() {
                    offer.offer(mime_type);
                }
                offer.source_actions(DndAction::convert_slice(&metadata.dnd_actions));

                device.enter((*serial).into(), self, location.x, location.y, Some(&offer));

                offers.push(offer);
            }

            Some(WlOfferData {
                state: offer_state,
                source,
                wl_offers: offers,
                last_source_actions: metadata.dnd_actions,
            })
        } else {
            None
        }
    }

    fn motion<S: Source>(
        &self,
        _data: &mut D,
        offer: Option<&mut WlOfferData<S>>,
        seat: &Seat<D>,
        location: Point<f64, Logical>,
        time: u32,
    ) {
        let seat_data = seat
            .user_data()
            .get::<RefCell<SeatData<D::SelectionUserData>>>()
            .unwrap()
            .borrow();

        if let Some(offer) = offer {
            if let Some(new_metadata) = offer.source.metadata() {
                if offer.last_source_actions != new_metadata.dnd_actions {
                    for wl_offer in &offer.wl_offers {
                        wl_offer.source_actions(DndAction::convert_slice(&new_metadata.dnd_actions));
                    }

                    offer.last_source_actions = new_metadata.dnd_actions;
                }
            };
        }

        for device in seat_data.known_data_devices() {
            if device.id().same_client_as(&self.id()) {
                device.motion(time, location.x, location.y);
            }
        }
    }

    fn leave<S: Source>(&self, _data: &mut D, _offer: Option<&mut WlOfferData<S>>, seat: &Seat<D>) {
        let seat_data = seat
            .user_data()
            .get::<RefCell<SeatData<D::SelectionUserData>>>()
            .unwrap()
            .borrow();
        for device in seat_data.known_data_devices() {
            if device.id().same_client_as(&self.id()) {
                device.leave();
            }
        }
    }

    fn drop<S: Source>(&self, _data: &mut D, offer: Option<&mut WlOfferData<S>>, seat: &Seat<D>) {
        let seat_data = seat
            .user_data()
            .get::<RefCell<SeatData<D::SelectionUserData>>>()
            .unwrap()
            .borrow();
        for device in seat_data.known_data_devices() {
            if let Some(ref offer) = offer {
                if device.version() >= wl_data_offer::REQ_SET_ACTIONS_SINCE
                    && offer.state.lock().unwrap().chosen_action.is_empty()
                {
                    continue;
                }
            }
            if device.id().same_client_as(&self.id()) {
                device.drop();
            }
        }
    }
}

/// State of data device
#[derive(Debug)]
pub struct DataDeviceState {
    manager_global: GlobalId,
    /// Used sources.
    ///
    /// Protocol states that each source can only be used once. We
    /// also use it during destruction to get seat data.
    pub(crate) used_sources: HashMap<WlDataSource, WlSeat>,
}

impl DataDeviceState {
    /// Regiseter new [WlDataDeviceManager] global
    pub fn new<D>(display: &DisplayHandle) -> Self
    where
        D: GlobalDispatch<WlDataDeviceManager, ()> + 'static,
        D: DataDeviceHandler,
    {
        let manager_global = display.create_global::<D, WlDataDeviceManager, _>(3, ());

        Self {
            manager_global,
            used_sources: Default::default(),
        }
    }

    /// [WlDataDeviceManager] GlobalId getter
    pub fn global(&self) -> GlobalId {
        self.manager_global.clone()
    }
}

/// A simple action chooser for DnD negociation
///
/// If the preferred action is available, it'll pick it. Otherwise, it'll pick the first
/// available in the following order: Ask, Copy, Move.
pub fn default_action_chooser(available: WlDndAction, preferred: WlDndAction) -> WlDndAction {
    // if the preferred action is valid (a single action) and in the available actions, use it
    // otherwise, follow a fallback stategy
    if [WlDndAction::Move, WlDndAction::Copy, WlDndAction::Ask].contains(&preferred)
        && available.contains(preferred)
    {
        preferred
    } else if available.contains(WlDndAction::Ask) {
        WlDndAction::Ask
    } else if available.contains(WlDndAction::Copy) {
        WlDndAction::Copy
    } else if available.contains(WlDndAction::Move) {
        WlDndAction::Move
    } else {
        WlDndAction::empty()
    }
}

/// Set the data device focus to a certain client for a given seat
///
/// If the focus is different from the existing focus, the current selection will be offered to the client.
#[instrument(name = "wayland_data_device", level = "debug", skip(dh, seat, client), fields(seat = seat.name(), client = ?client.as_ref().map(|c| c.id())))]
pub fn set_data_device_focus<D>(dh: &DisplayHandle, seat: &Seat<D>, client: Option<Client>)
where
    D: SeatHandler + DataDeviceHandler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));
    let seat_data = seat
        .user_data()
        .get::<RefCell<SeatData<D::SelectionUserData>>>()
        .unwrap();
    seat_data.borrow_mut().set_clipboard_focus::<D>(dh, client);
}

/// Set a compositor-provided selection for this seat
///
/// You need to provide the available mime types for this selection.
///
/// Whenever a client requests to read the selection, your callback will
/// receive a [`SelectionHandler::send_selection`] event.
#[instrument(name = "wayland_data_device", level = "debug", skip(dh, seat, user_data), fields(seat = seat.name()))]
pub fn set_data_device_selection<D>(
    dh: &DisplayHandle,
    seat: &Seat<D>,
    mime_types: Vec<String>,
    user_data: D::SelectionUserData,
) where
    D: SeatHandler + DataDeviceHandler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));

    let seat_data = seat
        .user_data()
        .get::<RefCell<SeatData<D::SelectionUserData>>>()
        .unwrap();

    let selection = OfferReplySource::Compositor(CompositorSelectionProvider {
        ty: SelectionTarget::Clipboard,
        mime_types,
        user_data,
    });

    seat_data
        .borrow_mut()
        .set_clipboard_selection::<D>(dh, Some(selection));
}

/// Errors happening when requesting selection contents
#[derive(Debug, thiserror::Error)]
pub enum SelectionRequestError {
    /// Requested mime type is not available
    #[error("Requested mime type is not available")]
    InvalidMimetype,
    /// Requesting server side selection contents is not supported
    #[error("Current selection is server-side")]
    ServerSideSelection,
    /// There is no active selection
    #[error("No active selection to query")]
    NoSelection,
}

/// Request the current data_device selection of the given seat
/// to be written to the provided file descriptor in the given mime type.
pub fn request_data_device_client_selection<D>(
    seat: &Seat<D>,
    mime_type: String,
    fd: OwnedFd,
) -> Result<(), SelectionRequestError>
where
    D: SeatHandler + DataDeviceHandler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));
    let seat_data = seat
        .user_data()
        .get::<RefCell<SeatData<D::SelectionUserData>>>()
        .unwrap();
    match seat_data.borrow().get_clipboard_selection() {
        None => Err(SelectionRequestError::NoSelection),
        Some(OfferReplySource::Client(source)) => {
            if !source.contains_mime_type(&mime_type) {
                Err(SelectionRequestError::InvalidMimetype)
            } else {
                source.send(mime_type, fd);
                Ok(())
            }
        }
        Some(OfferReplySource::Compositor(selection)) => {
            if !selection.mime_types.contains(&mime_type) {
                Err(SelectionRequestError::InvalidMimetype)
            } else {
                Err(SelectionRequestError::ServerSideSelection)
            }
        }
    }
}

/// Gets the user_data for the currently active selection, if set by the compositor
#[instrument(name = "wayland_data_device", level = "debug", skip_all, fields(seat = seat.name()))]
pub fn current_data_device_selection_userdata<D>(seat: &Seat<D>) -> Option<Ref<'_, D::SelectionUserData>>
where
    D: SeatHandler + DataDeviceHandler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));
    let seat_data = seat
        .user_data()
        .get::<RefCell<SeatData<D::SelectionUserData>>>()
        .unwrap();
    Ref::filter_map(seat_data.borrow(), |data| match data.get_clipboard_selection() {
        Some(OfferReplySource::Compositor(CompositorSelectionProvider { ref user_data, .. })) => {
            Some(user_data)
        }
        _ => None,
    })
    .ok()
}

/// Clear the current selection for this seat
#[instrument(name = "wayland_data_device", level = "debug", skip_all, fields(seat = seat.name()))]
pub fn clear_data_device_selection<D>(dh: &DisplayHandle, seat: &Seat<D>)
where
    D: SeatHandler + DataDeviceHandler + 'static,
{
    seat.user_data()
        .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));
    let seat_data = seat
        .user_data()
        .get::<RefCell<SeatData<D::SelectionUserData>>>()
        .unwrap();
    seat_data.borrow_mut().set_clipboard_selection::<D>(dh, None);
}

mod handlers {
    use std::cell::RefCell;

    use tracing::error;
    use wayland_server::{
        protocol::{
            wl_data_device::WlDataDevice,
            wl_data_device_manager::{self, WlDataDeviceManager},
            wl_data_source::WlDataSource,
        },
        Dispatch, DisplayHandle, GlobalDispatch,
    };

    use crate::{
        input::Seat,
        wayland::selection::{device::SelectionDevice, seat_data::SeatData},
    };

    use super::{device::DataDeviceUserData, source::DataSourceUserData};
    use super::{DataDeviceHandler, DataDeviceState};

    impl<D> GlobalDispatch<WlDataDeviceManager, (), D> for DataDeviceState
    where
        D: GlobalDispatch<WlDataDeviceManager, ()>,
        D: Dispatch<WlDataDeviceManager, ()>,
        D: Dispatch<WlDataSource, DataSourceUserData>,
        D: Dispatch<WlDataDevice, DataDeviceUserData>,
        D: DataDeviceHandler,
        D: 'static,
    {
        fn bind(
            _state: &mut D,
            _handle: &DisplayHandle,
            _client: &wayland_server::Client,
            resource: wayland_server::New<WlDataDeviceManager>,
            _global_data: &(),
            data_init: &mut wayland_server::DataInit<'_, D>,
        ) {
            data_init.init(resource, ());
        }
    }

    impl<D> Dispatch<WlDataDeviceManager, (), D> for DataDeviceState
    where
        D: Dispatch<WlDataDeviceManager, ()>,
        D: Dispatch<WlDataSource, DataSourceUserData>,
        D: Dispatch<WlDataDevice, DataDeviceUserData>,
        D: DataDeviceHandler,
        D: 'static,
    {
        fn request(
            _state: &mut D,
            client: &wayland_server::Client,
            _resource: &WlDataDeviceManager,
            request: wl_data_device_manager::Request,
            _data: &(),
            dhandle: &DisplayHandle,
            data_init: &mut wayland_server::DataInit<'_, D>,
        ) {
            match request {
                wl_data_device_manager::Request::CreateDataSource { id } => {
                    data_init.init(id, DataSourceUserData::new(dhandle.clone()));
                }
                wl_data_device_manager::Request::GetDataDevice { id, seat: wl_seat } => {
                    match Seat::<D>::from_resource(&wl_seat) {
                        Some(seat) => {
                            seat.user_data()
                                .insert_if_missing(|| RefCell::new(SeatData::<D::SelectionUserData>::new()));

                            let device = SelectionDevice::DataDevice(
                                data_init.init(id, DataDeviceUserData { wl_seat }),
                            );

                            let seat_data = seat
                                .user_data()
                                .get::<RefCell<SeatData<D::SelectionUserData>>>()
                                .unwrap();
                            seat_data.borrow_mut().add_device(device);
                        }
                        None => {
                            error!(client = ?client, data_device = ?id, "Unmanaged seat given to a data device.");
                        }
                    }
                }
                _ => unreachable!(),
            }
        }
    }
}

#[allow(missing_docs)] // TODO
#[macro_export]
macro_rules! delegate_data_device {
    ($(@<$( $lt:tt $( : $clt:tt $(+ $dlt:tt )* )? ),+>)? $ty: ty) => {
        const _: () = {
            use $crate::{
                reexports::wayland_server::{
                    delegate_dispatch, delegate_global_dispatch,
                    protocol::{
                        wl_data_device::WlDataDevice, wl_data_device_manager::WlDataDeviceManager,
                        wl_data_source::WlDataSource,
                    },
                },
                wayland::selection::data_device::{DataDeviceState, DataDeviceUserData, DataSourceUserData},
            };

            delegate_global_dispatch!(
                $(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
                $ty: [WlDataDeviceManager: ()] => DataDeviceState
            );

            delegate_dispatch!(
                $(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
                $ty: [WlDataDeviceManager: ()] => DataDeviceState
            );

            delegate_dispatch!(
                $(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
                $ty: [WlDataDevice: DataDeviceUserData] => DataDeviceState
            );

            delegate_dispatch!(
                $(@< $( $lt $( : $clt $(+ $dlt )* )? ),+ >)?
                $ty: [WlDataSource: DataSourceUserData] => DataDeviceState
            );
        };
    };
}
