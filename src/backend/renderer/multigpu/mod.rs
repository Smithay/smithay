//!
//! This module aims to make multi-gpu setups easier to handle for compositors.
//!
//! Its main entry point is the [`GpuManager`]. Initializing this with a
//! [`GraphicsApi`] implementation will allow you to create [`MultiRenderer`]s.
//!
//! smithay provides the following graphics apis:
//! - [`egl::EglGlesBackend`]
//!
//! A [`MultiRenderer`] gets created using two [`DrmNode`]s to identify gpus.
//! One gpu will be referred to as the render-gpu, the other as the target-gpu.
//!
//! Note: The render- and target-gpu may be identically to allow the multigpu
//! module to be used on single-gpu systems as well avoiding supporting multiple code-paths.
//! Doing so will not result in worse performance compared to rendering without the multi-gpu module.
//!
//! A [`MultiRenderer`] will support the [`Renderer`](super::Renderer)-trait as well
//! as the other corresponding traits of the [`renderer`](crate::backend::renderer)-module,
//! if the [`GraphicsApi`] allows it.
//!
//! Any rendering operations will take place on the render-gpu transparently.
//! Output will be redirected the target gpu, as such any [`Bind`]- and [`Offscreen`]-implementations
//! will be allocated on the target-gpu.
//!
//! The `ImportMem`-implementation will upload the texture on the render-gpu, failing *if*
//! the render-gpu does not support the format as normal. Be careful when mixing gpu's
//! with different memory-formats supported, what formats you annouce.
//!
//! In contrast the `ImportDma`-implementations will transparently create copies
//! of client buffers, if necessary, given it is unclear if a dmabuf can be imported on any given gpu.
//! The implementation strives for the best possible performance for a given setup,
//! when choosing a copy-path.
//!
//! Any `ExportMem`-implementations will originate from the render-gpu, which again
//! needs to support the requested format directly. No paths across other gpus are tested.
//!
//! *Note*: This module will not keep you from selecting sub-optimal configurations.
//! Any heuristics for which render-gpu to use for a given set of client buffers
//! and desired target-gpu are up to be implemented by the compositor. The module only
//! reduces the amount of necessary setup operations.
//!

use super::*;
use std::{
    any::{Any, TypeId},
    cell::{Ref, RefCell},
    collections::HashMap,
    convert::{AsMut, AsRef},
    fmt,
    rc::Rc,
};

#[cfg(feature = "wayland_frontend")]
use crate::wayland::{dmabuf::get_dmabuf, shm};
use crate::{
    backend::{
        allocator::{dmabuf::AnyError, Allocator, Buffer as BufferTrait, Format, Fourcc},
        color::null::NullCMS,
        drm::DrmNode,
        SwapBuffersError,
    },
    utils::{Buffer as BufferCoords, Physical, Size},
};
use tracing::{debug, info, info_span, instrument, trace, warn};
#[cfg(feature = "wayland_frontend")]
use wayland_server::protocol::{wl_buffer, wl_surface::WlSurface};
#[cfg(all(feature = "backend_egl", feature = "renderer_gl"))]
pub mod egl;
#[cfg(all(feature = "backend_gbm", feature = "backend_egl", feature = "renderer_gl"))]
pub mod gbm;

/// Tracks available gpus from a given [`GraphicsApi`]
#[derive(Debug)]
pub struct GpuManager<A: GraphicsApi> {
    api: A,
    devices: Vec<A::Device>,
    dmabuf_cache: HashMap<(DrmNode, DrmNode), Option<(bool, Dmabuf)>>,
    span: tracing::Span,
}

/// Errors generated by [`GpuManager`] and [`MultiRenderer`].
#[derive(thiserror::Error)]
pub enum Error<R: GraphicsApi, T: GraphicsApi>
where
    R::Error: 'static,
    T::Error: 'static,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    /// The graphics api errored on device enumeration
    #[error("The render graphics api failed enumerating devices {0:?}")]
    RenderApiError(#[source] R::Error),
    /// The graphics api errored on device enumeration
    #[error("The target graphics api failed enumerating devices {0:?}")]
    TargetApiError(#[source] T::Error),
    /// The graphics api has found no node matching the drm node
    #[error("The graphics api has found no node matching {0:?}")]
    NoDevice(DrmNode),
    /// The device requested did not match the expected
    #[error("The devices requested {0:?} did not match the expected")]
    MismatchedDevice(DrmNode),
    /// The device has gone missing
    #[error("The device has gone missing")]
    DeviceMissing,
    /// Error on the rendering device
    #[error("Error on the rendering device: {0:}")]
    Render(#[source] <<R::Device as ApiDevice>::Renderer as Renderer>::Error),
    /// Error on the target device
    #[error("Error on the target device: {0:}")]
    Target(#[source] <<T::Device as ApiDevice>::Renderer as Renderer>::Error),
    /// Failed to import buffer using the api on any device
    #[error("Failed to import buffer")]
    ImportFailed,
    /// Buffer allocation failed
    #[error("Failed to allocate buffer")]
    AllocatorError(AnyError),
}

impl<R: GraphicsApi, T: GraphicsApi> fmt::Debug for Error<R, T>
where
    R::Error: 'static,
    T::Error: 'static,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Error::RenderApiError(err) => write!(f, "Error::RenderApiError({:?})", err),
            Error::TargetApiError(err) => write!(f, "Error::TargetApiError({:?})", err),
            Error::NoDevice(dev) => write!(f, "Error::NoDevice({:?})", dev),
            Error::MismatchedDevice(dev) => write!(f, "Error::MismatchedDevice({:?})", dev),
            Error::DeviceMissing => write!(f, "Error::DeviceMissing"),
            Error::Render(err) => write!(f, "Error::Render({:?})", err),
            Error::Target(err) => write!(f, "Error::Target({:?})", err),
            Error::ImportFailed => write!(f, "Error::ImportFailed"),
            Error::AllocatorError(err) => write!(f, "Error::AllocationError({})", err),
        }
    }
}

impl<R: GraphicsApi + 'static, T: GraphicsApi + 'static> From<Error<R, T>> for SwapBuffersError
where
    R::Error: Into<SwapBuffersError> + Send + Sync,
    T::Error: Into<SwapBuffersError> + Send + Sync,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: Into<SwapBuffersError> + Send + Sync,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: Into<SwapBuffersError> + Send + Sync,
{
    fn from(err: Error<R, T>) -> SwapBuffersError {
        match err {
            x @ Error::NoDevice(_) | x @ Error::DeviceMissing | x @ Error::AllocatorError(_) => {
                SwapBuffersError::ContextLost(Box::new(x))
            }
            x @ Error::MismatchedDevice(_) | x @ Error::ImportFailed => {
                SwapBuffersError::TemporaryFailure(Box::new(x))
            }
            Error::RenderApiError(x) => x.into(),
            Error::TargetApiError(x) => x.into(),
            Error::Render(x) => x.into(),
            Error::Target(x) => x.into(),
        }
    }
}

impl<A: GraphicsApi> AsRef<A> for GpuManager<A> {
    fn as_ref(&self) -> &A {
        &self.api
    }
}

impl<A: GraphicsApi> AsMut<A> for GpuManager<A> {
    fn as_mut(&mut self) -> &mut A {
        &mut self.api
    }
}

impl<A: GraphicsApi> GpuManager<A> {
    /// Create a new [`GpuManager`] for a given [`GraphicsApi`].
    pub fn new(api: A) -> Result<GpuManager<A>, Error<A, A>> {
        let span = info_span!("renderer_multi", backend = A::identifier());

        let mut devices = Vec::new();
        api.enumerate(&mut devices).map_err(Error::RenderApiError)?;

        Ok(GpuManager {
            api,
            devices,
            dmabuf_cache: HashMap::new(),
            span,
        })
    }

    /// Create a [`MultiRenderer`] from a single device.
    ///
    /// This a convenience function to deal with the same types even, if you only need one device.
    /// Because no copies are necessary in these cases, all extra arguments can be omitted.
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    pub fn single_renderer<'api>(
        &'api mut self,
        device: &DrmNode,
    ) -> Result<MultiRenderer<'api, 'api, '_, A, A>, Error<A, A>> {
        if !self.devices.iter().any(|dev| dev.node() == device) {
            self.api
                .enumerate(&mut self.devices)
                .map_err(Error::RenderApiError)?;
        }

        if !self.devices.iter().any(|dev| dev.node() == device) {
            return Err(Error::NoDevice(*device));
        }

        let (mut render, others) = self
            .devices
            .iter_mut()
            .partition::<Vec<_>, _>(|dev| dev.node() == device);
        Ok(MultiRenderer {
            render: render.remove(0),
            target: None,
            other_renderers: others,
            span: tracing::Span::current(),
        })
    }

    /// Create a [`MultiRenderer`].
    ///
    /// - `render_device` should referr to the gpu node rendering operations will take place upon.
    /// - `target_device` should referr to the gpu node the composited buffer will end up upon
    /// - `allocator` should referr to an `Allocator`, that works guaranteed with the `render_device`
    ///     to do offscreen composition on. Dma copies will be used, if buffers returned by the allocator
    ///     also work on the `target_device`.
    /// - `copy_format` denotes the format buffers will be allocated in for offscreen rendering.
    ///
    /// It is valid to pass the same devices for both, but you *should* use [`GraphicsApi::single_renderer`] in those cases.
    #[instrument(level = "trace", parent = &self.span, skip(self, allocator))]
    pub fn renderer<'api, 'alloc>(
        &'api mut self,
        render_device: &DrmNode,
        target_device: &DrmNode,
        allocator: &'alloc mut dyn Allocator<Buffer = Dmabuf, Error = AnyError>,
        copy_format: Fourcc,
    ) -> Result<MultiRenderer<'api, 'api, 'alloc, A, A>, Error<A, A>>
    where
        <A::Device as ApiDevice>::Renderer: Bind<Dmabuf>,
    {
        if !self.devices.iter().any(|device| device.node() == render_device)
            || !self.devices.iter().any(|device| device.node() == target_device)
        {
            self.api
                .enumerate(&mut self.devices)
                .map_err(Error::RenderApiError)?;
        }

        if !self.devices.iter().any(|device| device.node() == render_device) {
            return Err(Error::NoDevice(*render_device));
        }
        if !self.devices.iter().any(|device| device.node() == target_device) {
            return Err(Error::NoDevice(*target_device));
        }

        let (mut render, others) = self
            .devices
            .iter_mut()
            .partition::<Vec<_>, _>(|device| device.node() == render_device);
        if target_device != render_device {
            let (mut target, others) = others
                .into_iter()
                .partition::<Vec<_>, _>(|device| device.node() == target_device);

            Ok(MultiRenderer {
                render: render.remove(0),
                target: Some(TargetData {
                    device: target.remove(0),
                    allocator,
                    cached_buffer: self
                        .dmabuf_cache
                        .entry((*render_device, *target_device))
                        .or_default(),
                    format: copy_format,
                }),
                other_renderers: others,
                span: tracing::Span::current(),
            })
        } else {
            Ok(MultiRenderer {
                render: render.remove(0),
                target: None,
                other_renderers: others,
                span: tracing::Span::current(),
            })
        }
    }

    /// Create a [`MultiRenderer`] from two different [`GraphicsApi`]s.
    ///
    /// - `render_api` should be the [`GpuManager`] used for the `render_device`.
    /// - `target_api` should be the [`GpuManager`] used for the `target_device`.
    /// - `render_device` should referr to the gpu node rendering operations will take place upon.
    /// - `target_device` should referr to the gpu node the composited buffer will end up upon
    /// - `allocator` should referr to an `Allocator`, that works guaranteed with the `render_device`
    ///     to do offscreen composition on. Dma copies will be used, if buffers returned by the allocator
    ///     also work on the `target_device`.
    /// - `copy_format` denotes the format buffers will be allocated in for offscreen rendering.
    #[instrument(level = "trace", skip(render_api, target_api, allocator), follows_from = [&render_api.span, &target_api.span])]
    pub fn cross_renderer<'render, 'target, 'alloc, B: GraphicsApi, Alloc: Allocator>(
        render_api: &'render mut Self,
        target_api: &'target mut GpuManager<B>,
        render_device: &DrmNode,
        target_device: &DrmNode,
        allocator: &'alloc mut dyn Allocator<Buffer = Dmabuf, Error = AnyError>,
        copy_format: Fourcc,
    ) -> Result<MultiRenderer<'render, 'target, 'alloc, A, B>, Error<A, B>>
    where
        <A::Device as ApiDevice>::Renderer: Bind<Dmabuf>,
        <B::Device as ApiDevice>::Renderer: ImportDma,
    {
        if !render_api
            .devices
            .iter()
            .any(|device| device.node() == render_device)
        {
            render_api
                .api
                .enumerate(&mut render_api.devices)
                .map_err(Error::RenderApiError)?;
        }

        if !target_api
            .devices
            .iter()
            .any(|device| device.node() == target_device)
        {
            target_api
                .api
                .enumerate(&mut target_api.devices)
                .map_err(Error::TargetApiError)?;
        }

        if !render_api
            .devices
            .iter()
            .any(|device| device.node() == render_device)
        {
            return Err(Error::NoDevice(*render_device));
        }
        if !target_api
            .devices
            .iter()
            .any(|device| device.node() == target_device)
        {
            return Err(Error::NoDevice(*target_device));
        }

        let (mut render, others) = render_api
            .devices
            .iter_mut()
            .partition::<Vec<_>, _>(|device| device.node() == render_device);
        if target_device != render_device {
            let target = target_api
                .devices
                .iter_mut()
                .find(|device| device.node() == target_device)
                .unwrap();

            Ok(MultiRenderer {
                render: render.remove(0),
                target: Some(TargetData {
                    device: target,
                    allocator,
                    cached_buffer: target_api
                        .dmabuf_cache
                        .entry((*render_device, *target_device))
                        .or_default(),
                    format: copy_format,
                }),
                other_renderers: others,
                span: tracing::Span::current(),
            })
        } else {
            Ok(MultiRenderer {
                render: render.remove(0),
                target: None,
                other_renderers: others,
                span: tracing::Span::current(),
            })
        }
    }

    /// Function for optimizing buffer imports across multiple gpus.
    ///
    /// If you are using [`MultiRenderer`]s do rendering of your client buffers,
    /// you can call `early_import` on commit to start necessary copy processes early.
    ///
    /// - `source` may specify on which gpu node the provided buffer is allocated on, if applicable.
    /// - `target` referrs to the gpu node, that the buffer needs to be accessable on later.
    ///    *Note*: Usually this will be **render**ing gpu of a [`MultiRenderer`]
    /// - `surface` is the wayland surface, whos buffer and subsurfaces buffers shall be imported
    ///
    /// Note: This will do nothing, if you are not using
    /// [`crate::backend::renderer::utils::on_commit_buffer_handler`]
    /// to let smithay handle buffer management.
    #[cfg(feature = "wayland_frontend")]
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    pub fn early_import(
        &mut self,
        source: Option<DrmNode>,
        target: DrmNode,
        surface: &WlSurface,
    ) -> Result<(), Error<A, A>>
    where
        A: 'static,
        <A::Device as ApiDevice>::Renderer: ImportMemWl + ImportDmaWl + ExportMem,
        <<A::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    {
        use crate::{
            backend::renderer::utils::RendererSurfaceState,
            wayland::compositor::{with_surface_tree_upward, TraversalAction},
        };

        let mut result = Ok(());
        with_surface_tree_upward(
            surface,
            (),
            |_surface, states, _| {
                if let Some(data) = states.data_map.get::<RefCell<RendererSurfaceState>>() {
                    let mut data_ref = data.borrow_mut();
                    let data = &mut *data_ref;
                    if data.textures.is_empty() {
                        // Import a new buffer if available
                        if let Some(buffer) = data.buffer.as_ref() {
                            // We do an optimistic optimization here, so contrary to many much more defensive damage-tracking algorithms,
                            // we only import the most recent set of damage here.
                            // If we need more on rendering - which we cannot know at this point - we will call import_missing later
                            // to receive the rest.
                            let buffer_damage = data.damage().take(1).flatten().cloned().fold(
                                Vec::<Rectangle<i32, BufferCoords>>::new(),
                                |damage, mut rect| {
                                    // replace with drain_filter, when that becomes stable to reuse the original Vec's memory
                                    let (overlapping, mut new_damage): (Vec<_>, Vec<_>) = damage
                                        .into_iter()
                                        .partition(|other| other.overlaps_or_touches(rect));

                                    for overlap in overlapping {
                                        rect = rect.merge(overlap);
                                    }
                                    new_damage.push(rect);
                                    new_damage
                                },
                            );

                            if let Err(err) =
                                self.early_import_buffer(source, target, buffer, states, &buffer_damage)
                            {
                                result = Err(err);
                            }
                        }
                        // Now, was the import successful?
                        if result.is_ok() {
                            TraversalAction::DoChildren(())
                        } else {
                            // we are not displayed, so our children are neither
                            TraversalAction::SkipChildren
                        }
                    } else {
                        TraversalAction::SkipChildren
                    }
                } else {
                    TraversalAction::SkipChildren
                }
            },
            |_, _, _| {},
            |_, _, _| true,
        );

        result
    }

    #[cfg(feature = "wayland_frontend")]
    fn early_import_buffer(
        &mut self,
        source: Option<DrmNode>,
        target: DrmNode,
        buffer: &wl_buffer::WlBuffer,
        surface: &SurfaceData,
        damage: &[Rectangle<i32, BufferCoords>],
    ) -> Result<(), Error<A, A>>
    where
        A: 'static,
        <A::Device as ApiDevice>::Renderer: ImportMemWl + ImportDmaWl + ExportMem,
        <<A::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    {
        match buffer_type(buffer) {
            Some(BufferType::Dma) => {
                let (mut target_device, others) = self
                    .devices
                    .iter_mut()
                    .partition::<Vec<_>, _>(|device| device.node() == &target);
                let target_device = target_device.get_mut(0).ok_or(Error::DeviceMissing)?;
                let dmabuf = get_dmabuf(buffer).unwrap();
                let format = dmabuf.format();

                if target_device.renderer().dmabuf_formats().any(|f| f == format) {
                    match target_device
                        .renderer_mut()
                        .import_dma_buffer(buffer, Some(surface), damage)
                    {
                        Ok(imported) => {
                            let mut texture = MultiTexture::from_surface(Some(surface), imported.size());
                            texture.insert_texture::<A>(target, imported);
                            surface.data_map.insert_if_missing(|| texture.0);
                            return Ok(());
                        }
                        Err(err) => {
                            trace!(
                                "Error importing dmabuf (format: {:?}) to {}: {}",
                                format,
                                target,
                                err
                            );
                            trace!("Falling back to cpu-copy.");
                        }
                    }
                }

                // if we do need to do a memory copy, we start with the export early
                let (first, last) = match source {
                    Some(s) => others
                        .into_iter()
                        .partition::<Vec<_>, _>(|other| other.node() == &s),
                    None => (Vec::new(), others),
                };
                for import_renderer in first.into_iter().chain(last.into_iter()) {
                    if let Ok(texture) =
                        import_renderer
                            .renderer_mut()
                            .import_dma_buffer(buffer, Some(surface), damage)
                    {
                        let mut gpu_texture = MultiTexture::from_surface(Some(surface), texture.size());
                        let format = texture
                            .format()
                            // Check the target device supports the format, if not use 8-bit format
                            .filter(|format| target_device.renderer().mem_formats().any(|fmt| fmt == *format))
                            // The GL spec *always* supports this format.
                            // TODO: Re-evaluate this, once we support vulkan
                            .unwrap_or(Fourcc::Abgr8888);
                        let mappings = if gpu_texture.get::<A>(&target).is_none() {
                            // force full copy
                            let damage = Rectangle::from_loc_and_size((0, 0), texture.size());
                            vec![(
                                damage,
                                import_renderer
                                    .renderer_mut()
                                    .copy_texture(&texture, damage, format)
                                    .map_err(Error::Target)?,
                            )]
                        } else {
                            let damage = damage
                                .iter()
                                .flat_map(|rect| {
                                    rect.intersection(Rectangle::from_loc_and_size((0, 0), texture.size()))
                                })
                                .fold(Vec::<Rectangle<i32, BufferCoords>>::new(), |damage, mut rect| {
                                    // replace with drain_filter, when that becomes stable to reuse the original Vec's memory
                                    let (overlapping, mut new_damage): (Vec<_>, Vec<_>) = damage
                                        .into_iter()
                                        .partition(|other| other.overlaps_or_touches(rect));

                                    for overlap in overlapping {
                                        rect = rect.merge(overlap);
                                    }
                                    new_damage.push(rect);
                                    new_damage
                                });
                            // do a partial copy
                            damage
                                .iter()
                                .copied()
                                .map(|damage| {
                                    let mapping = import_renderer
                                        .renderer_mut()
                                        .copy_texture(&texture, damage, format)
                                        .map_err(Error::Target)?;
                                    Ok((damage, mapping))
                                })
                                .collect::<Result<Vec<_>, Error<A, A>>>()?
                        };
                        gpu_texture.insert_mapping::<A, A, _>(
                            *import_renderer.node(),
                            target,
                            texture.size(),
                            mappings.into_iter(),
                        );
                        surface.data_map.insert_if_missing(|| gpu_texture.0);
                        return Ok(());
                    }
                }

                Err(Error::ImportFailed)
            }
            #[cfg(all(
                feature = "wayland_frontend",
                feature = "backend_egl",
                feature = "use_system_lib"
            ))]
            Some(BufferType::Egl) => {
                // we need specialization for requiring ImportEGL
                // or require ImportAll, which will block this function for all
                // renderers that cannot import egl buffers, so we just don't
                // and sadly go the slow path
                Ok(())
            }
            Some(BufferType::Shm) => {
                // we just need to upload in import_shm_buffer
                Ok(())
            }
            None => {
                // welp, nothing we can do
                Ok(())
            }
        }
    }
}

/// A graphics api, that supports enumerating graphics devices
pub trait GraphicsApi {
    /// Devices this api produces
    type Device: ApiDevice;
    /// Errors this api returns
    type Error: std::error::Error;

    /// Enumerate available devices by:
    /// - removing gone devices from list
    /// - adding new devices to list
    ///
    /// Existing devices are guranteed to be not recreated
    fn enumerate(&self, list: &mut Vec<Self::Device>) -> Result<(), Self::Error>;
    /// Unique name for representing the api type in log messages
    fn identifier() -> &'static str;
}

/// A device produced by a [`GraphicsApi`].
pub trait ApiDevice {
    /// The [`Renderer`](super::Renderer) this devices contains
    type Renderer: Renderer;

    /// Returns a reference to the underlying renderer
    fn renderer(&self) -> &Self::Renderer;
    /// Returns a mutable reference to the underlying renderer
    fn renderer_mut(&mut self) -> &mut Self::Renderer;
    /// Returns a [`DrmNode`] representing the graphics device
    fn node(&self) -> &DrmNode;
}

/// Renderer, that transparently copies rendering results to another gpu,
/// as well as transparently importing client buffers residing on different gpus.
pub struct MultiRenderer<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> {
    render: &'render mut R::Device,
    target: Option<TargetData<'target, 'alloc, T>>,
    other_renderers: Vec<&'render mut R::Device>,
    span: tracing::Span,
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> fmt::Debug
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <<T::Device as ApiDevice>::Renderer as Renderer>::TextureId: fmt::Debug,
    R::Device: fmt::Debug,
    T::Device: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MultiRenderer")
            .field("render", &self.render)
            .field("target", &self.target)
            .field("other_renderers", &self.other_renderers)
            .finish()
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> AsRef<<R::Device as ApiDevice>::Renderer>
    for MultiRenderer<'render, 'target, 'alloc, R, T>
{
    fn as_ref(&self) -> &<R::Device as ApiDevice>::Renderer {
        self.render.renderer()
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> AsMut<<R::Device as ApiDevice>::Renderer>
    for MultiRenderer<'render, 'target, 'alloc, R, T>
{
    fn as_mut(&mut self) -> &mut <R::Device as ApiDevice>::Renderer {
        self.render.renderer_mut()
    }
}

/// [`Frame`](super::Frame) implementation of a [`MultiRenderer`].
///
/// Leaking the frame will potentially keep it from doing necessary copies
/// of the internal framebuffer for some multi-gpu configurations. The result would
/// be no updated framebuffer contents.
/// Additionally all problems related to the Frame-implementation of the underlying
/// [`GraphicsApi`] will be present.
pub struct MultiFrame<
    'render,
    'target,
    'alloc,
    'frame,
    'color,
    R: GraphicsApi + 'frame,
    T: GraphicsApi,
    C: CMS + 'static,
> where
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    node: DrmNode,
    frame: Option<<<R::Device as ApiDevice>::Renderer as Renderer>::Frame<'frame, 'color, C>>,
    render: *mut &'render mut R::Device,
    target: &'frame mut Option<TargetData<'target, 'alloc, T>>,
    target_texture: Option<<<T::Device as ApiDevice>::Renderer as Renderer>::TextureId>,

    dst_transform: Transform,
    size: Size<i32, Physical>,
    damage: Vec<Rectangle<i32, Physical>>,
    span: tracing::span::EnteredSpan,
}

struct TargetData<'target, 'alloc, T: GraphicsApi> {
    device: &'target mut T::Device,
    allocator: &'alloc mut dyn Allocator<Buffer = Dmabuf, Error = AnyError>,
    cached_buffer: &'target mut Option<(bool, Dmabuf)>,
    format: Fourcc,
}

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi + 'frame, T: GraphicsApi, C: CMS> fmt::Debug
    for MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::TextureId: fmt::Debug,
    R::Device: fmt::Debug,
    T::Device: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MultiFrame")
            .field("node", &self.node)
            .field("render", unsafe { &*self.render })
            .field("target", &self.target)
            .field("dst_transform", &self.dst_transform)
            .field("size", &self.size)
            .field("damage", &self.damage)
            .finish()
    }
}

impl<'target, 'alloc, T: GraphicsApi> fmt::Debug for TargetData<'target, 'alloc, T>
where
    T::Device: fmt::Debug,
    <<T::Device as ApiDevice>::Renderer as Renderer>::TextureId: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("TargetData")
            .field("device", self.device)
            .field("allocator", &"...")
            .field("cached_buffer", &self.cached_buffer)
            .field("format", &self.format)
            .finish()
    }
}

// These casts are ok, because the frame cannot outlive the MultiFrame,
// see MultiRenderer::render for how this hack works and why it is necessary.

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi, T: GraphicsApi, C>
    AsRef<<<R::Device as ApiDevice>::Renderer as Renderer>::Frame<'frame, 'color, C>>
    for MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    C: CMS + 'static,
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn as_ref(&self) -> &<<R::Device as ApiDevice>::Renderer as Renderer>::Frame<'frame, 'color, C> {
        self.frame.as_ref().unwrap()
    }
}

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi, T: GraphicsApi, C>
    AsMut<<<R::Device as ApiDevice>::Renderer as Renderer>::Frame<'frame, 'color, C>>
    for MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    C: CMS + 'static,
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn as_mut(&mut self) -> &mut <<R::Device as ApiDevice>::Renderer as Renderer>::Frame<'frame, 'color, C> {
        self.frame.as_mut().unwrap()
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> Unbind
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <T::Device as ApiDevice>::Renderer: Unbind,
    <R::Device as ApiDevice>::Renderer: Unbind,
    // We need this because the Renderer-impl does and Unbind requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn unbind(&mut self) -> Result<(), <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target.device.renderer_mut().unbind().map_err(Error::Target)
        } else {
            self.render.renderer_mut().unbind().map_err(Error::Render)
        }
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi, Target> Offscreen<Target>
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <T::Device as ApiDevice>::Renderer: Offscreen<Target>,
    <R::Device as ApiDevice>::Renderer: Offscreen<Target>,
    // We need these because the Bind-impl does and Offscreen requires Bind
    <T::Device as ApiDevice>::Renderer: Bind<Target>,
    <R::Device as ApiDevice>::Renderer: Bind<Target>,
    // We need these because the Unbind-impl does and Offscreen requires Bind, which requires Unbind
    <R::Device as ApiDevice>::Renderer: Unbind,
    <T::Device as ApiDevice>::Renderer: Unbind,
    // We need these because the Renderer-impl does and Offscreen requires Bind, which requires Unbind, which requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn create_buffer(
        &mut self,
        format: Fourcc,
        size: Size<i32, BufferCoords>,
    ) -> Result<Target, <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target
                .device
                .renderer_mut()
                .create_buffer(format, size)
                .map_err(Error::Target)
        } else {
            self.render
                .renderer_mut()
                .create_buffer(format, size)
                .map_err(Error::Render)
        }
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi, Target> Bind<Target>
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <T::Device as ApiDevice>::Renderer: Bind<Target>,
    <R::Device as ApiDevice>::Renderer: Bind<Target>,
    // We need these because the Unbind-impl does and Bind requires Unbind
    <R::Device as ApiDevice>::Renderer: Unbind,
    <T::Device as ApiDevice>::Renderer: Unbind,
    // We need this because the Renderer-impl does and Bind requires Unbind, which requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self, bind))]
    fn bind(&mut self, bind: Target) -> Result<(), <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target.device.renderer_mut().bind(bind).map_err(Error::Target)
        } else {
            self.render.renderer_mut().bind(bind).map_err(Error::Render)
        }
    }

    fn supported_formats(&self) -> Option<HashSet<crate::backend::allocator::Format>> {
        if let Some(target) = self.target.as_ref() {
            Bind::<Target>::supported_formats(target.device.renderer())
        } else {
            Bind::<Target>::supported_formats(self.render.renderer())
        }
    }
}

static MAX_CPU_COPIES: usize = 3; // TODO, benchmark this

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> Renderer
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    type Error = Error<R, T>;
    type TextureId = MultiTexture;
    type Frame<'frame, 'color, C: CMS + 'static> = MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C> where Self: 'frame;

    fn id(&self) -> usize {
        self.render.renderer().id()
    }

    fn downscale_filter(&mut self, filter: TextureFilter) -> Result<(), Self::Error> {
        self.render
            .renderer_mut()
            .downscale_filter(filter)
            .map_err(Error::Render)
    }
    fn upscale_filter(&mut self, filter: TextureFilter) -> Result<(), Self::Error> {
        self.render
            .renderer_mut()
            .upscale_filter(filter)
            .map_err(Error::Render)
    }

    fn set_debug_flags(&mut self, flags: DebugFlags) {
        self.render.renderer_mut().set_debug_flags(flags)
    }
    fn debug_flags(&self) -> DebugFlags {
        self.render.renderer().debug_flags()
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, cms, output_profile))]
    fn render<'frame, 'color, C: CMS + 'static>(
        &'frame mut self,
        size: Size<i32, Physical>,
        dst_transform: Transform,
        cms: &'color mut C,
        output_profile: &'color C::ColorProfile,
    ) -> Result<MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>, Self::Error> {
        let target_texture = if let Some(target) = self.target.as_mut() {
            let buffer_size = size.to_logical(1).to_buffer(1, Transform::Normal);

            if let Some((_, dmabuf)) = &target.cached_buffer {
                if dmabuf.size() != buffer_size
                    || BufferTrait::format(dmabuf).code != target.format
                    || self.render.renderer_mut().bind(dmabuf.clone()).is_err()
                {
                    *target.cached_buffer = None;
                }
            };

            if target.cached_buffer.is_none() {
                let target_formats = ImportDma::dmabuf_formats(target.device.renderer())
                    .filter(|format| format.code == target.format)
                    .collect::<HashSet<Format>>();
                let render_formats =
                    Bind::<Dmabuf>::supported_formats(self.render.renderer()).unwrap_or_default();
                let formats = target_formats.intersection(&render_formats);
                let target_modifiers = formats.map(|format| format.modifier).collect::<Vec<_>>();

                let mut direct = true;
                let modifiers = if !target_modifiers.is_empty() {
                    info!(
                        "Found dma-copy set for {:?} -> {:?}",
                        self.render.node(),
                        target.device.node(),
                    );
                    target_modifiers
                } else {
                    direct = false;
                    render_formats
                        .iter()
                        .copied()
                        .filter(|format| format.code == target.format)
                        .map(|f| f.modifier)
                        .collect::<Vec<_>>()
                };

                let dmabuf = target
                    .allocator
                    .create_buffer(
                        buffer_size.w as u32,
                        buffer_size.h as u32,
                        target.format,
                        &modifiers,
                    )
                    .or_else(|_| {
                        direct = false;
                        target.allocator.create_buffer(
                            buffer_size.w as u32,
                            buffer_size.h as u32,
                            target.format,
                            &render_formats
                                .into_iter()
                                .filter(|format| format.code == target.format)
                                .map(|f| f.modifier)
                                .collect::<Vec<_>>(),
                        )
                    })
                    .map_err(Error::AllocatorError)?;

                // import on render node
                self.render
                    .renderer_mut()
                    .bind(dmabuf.clone())
                    .map_err(Error::Render)?;

                *target.cached_buffer = Some((direct, dmabuf));
            };

            let (direct, dmabuf) = target.cached_buffer.as_mut().unwrap();

            // try to import on target node
            if *direct {
                match target
                    .device
                    .renderer_mut()
                    .import_dmabuf(dmabuf, Some(&[Rectangle::from_loc_and_size((0, 0), buffer_size)]))
                {
                    Ok(texture) => {
                        // import successful!
                        trace!("Target device dmabuf import successful!");
                        Some(texture)
                    }
                    Err(err) => {
                        let (source, target, format) =
                            (*self.render.node(), *target.device.node(), dmabuf.format());
                        warn!(
                            "Error importing dmabuf (format: {:?}) from {} to {}: {}",
                            format, source, target, err
                        );
                        info!("Falling back to cpu-copy.");
                        *direct = false;
                        None
                    }
                }
            } else {
                None
            }
            // TODO: We could cache that texture all the way back to the GpuManager in a HashMap<WeakDmabuf, Texture>.
        } else {
            None
        };

        let node = *self.render.node();

        let ptr = &mut self.render as *mut _;
        let frame = self
            .render
            .renderer_mut()
            .render(size, dst_transform, cms, output_profile)
            .map_err(Error::Render)?;

        let span = info_span!(
            parent: &self.span,
            "renderer_multi_frame",
            direct = target_texture.is_some(),
        )
        .entered();

        Ok(MultiFrame {
            node,
            frame: Some(frame),
            render: ptr, // this is fine, as long as we have the frame, this ptr is valid
            target: &mut self.target,
            target_texture,
            dst_transform,
            size,
            damage: Vec::new(),
            span,
        })
    }
}

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi, T: GraphicsApi, C>
    MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    C: CMS + 'static,
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn finish_internal(&mut self) -> Result<(), Error<R, T>> {
        if let Some(frame) = self.frame.take() {
            frame.finish().map_err(Error::Render)?;

            // now the frame is gone, lets use our unholy ptr till the end of this call:
            // SAFETY:
            // - The renderer will never be invalid because the lifetime of the frame must be shorter than the renderer.
            // - The pointer can't be aliased because of the following:
            //   - Creating a frame requires an `&mut` reference to the renderer, making the mutable borrow safe.
            //   - The mutable reference is used in a function which mutably borrows the frame, that either being `.finish()`
            //      (which takes ownership of the frame) or dropping the frame.
            let render = unsafe { &mut *self.render };

            let damage_area = self.dst_transform.transform_size(self.size.to_logical(1));
            let mut damage = std::mem::take(&mut self.damage)
                .into_iter()
                .map(|rect| rect.to_logical(1).to_buffer(1, self.dst_transform, &damage_area))
                .collect::<Vec<_>>();

            let buffer_size = self.size.to_logical(1).to_buffer(1, Transform::Normal);
            if let Some(target) = self.target.as_mut() {
                if let Some(texture) = self.target_texture.as_ref() {
                    // try gpu copy
                    let damage = damage
                        .iter()
                        .map(|rect| rect.to_logical(1, Transform::Normal, &buffer_size).to_physical(1))
                        .collect::<Vec<_>>();
                    let mut cms = NullCMS;
                    let profile = cms.profile_srgb();
                    let mut frame = target
                        .device
                        .renderer_mut()
                        .render(self.size, Transform::Normal, &mut cms, &profile)
                        .map_err(Error::Target)?;
                    frame
                        .clear([0.0, 0.0, 0.0, 0.0], &damage, &profile)
                        .map_err(Error::Target)?;
                    frame
                        .render_texture_from_to(
                            texture,
                            Rectangle::from_loc_and_size((0, 0), buffer_size).to_f64(),
                            Rectangle::from_loc_and_size((0, 0), self.size),
                            &damage,
                            Transform::Normal,
                            1.0,
                            &profile,
                        )
                        .map_err(Error::Target)?;
                    frame.finish().map_err(Error::Target)?;

                    return Ok(());
                }

                let format = if target
                    .device
                    .renderer()
                    .mem_formats()
                    .any(|fmt| fmt == target.format)
                {
                    target.format
                } else {
                    // GL mandates this to be supported for downloading, this will truncate 10-bit data
                    Fourcc::Abgr8888
                };

                // cpu copy
                damage.dedup();
                damage.retain(|rect| {
                    rect.overlaps_or_touches(Rectangle::from_loc_and_size((0, 0), buffer_size))
                });
                damage.retain(|rect| rect.size.h > 0 && rect.size.w > 0);

                let mut copy_rects = // merge overlapping rectangles
                    damage.iter().cloned().fold(Vec::new(), |new_damage, mut rect| {
                        // replace with drain_filter, when that becomes stable to reuse the original Vec's memory
                        let (overlapping, mut new_damage): (Vec<_>, Vec<_>) = new_damage
                            .into_iter()
                            .partition(|other: &Rectangle<i32, BufferCoords>| other.overlaps_or_touches(rect));

                        for overlap in overlapping {
                            rect = rect.merge(overlap);
                        }
                        new_damage.push(rect);
                        new_damage
                    });
                if copy_rects.len() > MAX_CPU_COPIES {
                    copy_rects = Vec::from([Rectangle::from_loc_and_size((0, 0), buffer_size)]);
                }

                let mut mappings = Vec::new();
                for rect in copy_rects {
                    let mapping = (
                        ExportMem::copy_framebuffer(render.renderer_mut(), rect, format)
                            .map_err(Error::Render)?,
                        rect,
                    );
                    mappings.push(mapping);
                }

                for (mapping, rect) in mappings {
                    let slice = ExportMem::map_texture(render.renderer_mut(), &mapping)
                        .map_err(Error::Render::<R, T>)?;
                    let texture = target
                        .device
                        .renderer_mut()
                        .import_memory(slice, TextureMapping::format(&mapping), rect.size, false)
                        .map_err(Error::Target)?;
                    let mut cms = NullCMS;
                    let profile = cms.profile_srgb();
                    let mut frame = target
                        .device
                        .renderer_mut()
                        .render(self.size, Transform::Normal, &mut cms, &profile)
                        .map_err(Error::Target)?;
                    for damage_rect in damage.iter().filter_map(|dmg_rect| dmg_rect.intersection(rect)) {
                        let dst = damage_rect
                            .to_logical(1, Transform::Normal, &buffer_size)
                            .to_physical(1);
                        let src = Rectangle::from_loc_and_size(damage_rect.loc - rect.loc, damage_rect.size)
                            .to_f64();
                        let damage = &[Rectangle::from_loc_and_size((0, 0), dst.size)];
                        frame
                            .clear([0.0, 0.0, 0.0, 0.0], &[dst], &profile)
                            .map_err(Error::Target)?;
                        frame
                            .render_texture_from_to(
                                &texture,
                                src,
                                dst,
                                damage,
                                Transform::Normal,
                                1.0,
                                &profile,
                            )
                            .map_err(Error::Target)?;
                    }
                    frame.finish().map_err(Error::Target)?;
                }
            }
        }

        Ok(())
    }
}

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi, T: GraphicsApi, C> Drop
    for MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    C: CMS + 'static,
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn drop(&mut self) {
        if let Err(err) = self.finish_internal() {
            warn!("Ignored error finishing MultiFrame on drop: {}", err);
        }
    }
}

/// [`Texture`](super::Texture)s produced by a [`MultiRenderer`].
#[derive(Debug, Clone)]
pub struct MultiTexture(Rc<RefCell<MultiTextureInternal>>);
#[derive(Debug)]
struct MultiTextureInternal {
    textures: HashMap<TypeId, HashMap<DrmNode, GpuSingleTexture>>,
    size: Size<i32, BufferCoords>,
    format: Option<Fourcc>,
}

type DamageAnyTextureMappings = Vec<(Rectangle<i32, BufferCoords>, Box<dyn Any + 'static>)>;
#[derive(Debug)]
struct GpuSingleTexture {
    mapping: Option<(DrmNode, DamageAnyTextureMappings)>,
    texture: Option<Box<dyn Any + 'static>>,
}

impl MultiTexture {
    #[cfg(feature = "wayland_frontend")]
    fn from_surface(
        surface: Option<&crate::wayland::compositor::SurfaceData>,
        size: Size<i32, BufferCoords>,
    ) -> MultiTexture {
        let internal = surface
            .and_then(|surface| {
                surface
                    .data_map
                    .get::<Rc<RefCell<MultiTextureInternal>>>()
                    .cloned()
            })
            .unwrap_or_else(|| {
                Rc::new(RefCell::new(MultiTextureInternal {
                    textures: HashMap::new(),
                    size,
                    format: None,
                }))
            });
        {
            let mut internal = internal.borrow_mut();
            if internal.size != size {
                internal.textures.clear();
                internal.size = size;
            }
        }
        MultiTexture(internal)
    }

    fn new(size: Size<i32, BufferCoords>) -> MultiTexture {
        MultiTexture(Rc::new(RefCell::new(MultiTextureInternal {
            textures: HashMap::new(),
            size,
            format: None,
        })))
    }

    fn get<A: GraphicsApi + 'static>(
        &self,
        render: &DrmNode,
    ) -> Option<Ref<'_, <<A::Device as ApiDevice>::Renderer as Renderer>::TextureId>>
    where
        <<A::Device as ApiDevice>::Renderer as Renderer>::TextureId: 'static,
    {
        let tex = self.0.borrow();
        Ref::filter_map(tex, |tex| {
            tex.textures
                .get(&TypeId::of::<A>())
                .and_then(|textures| textures.get(render))
                .and_then(|texture| texture.texture.as_ref())
                .and_then(|texture| {
                    <dyn Any>::downcast_ref::<<<A::Device as ApiDevice>::Renderer as Renderer>::TextureId>(
                        &**texture,
                    )
                })
        })
        .ok()
    }

    fn insert_texture<A: GraphicsApi + 'static>(
        &mut self,
        render: DrmNode,
        texture: <<A::Device as ApiDevice>::Renderer as Renderer>::TextureId,
    ) where
        <<A::Device as ApiDevice>::Renderer as Renderer>::TextureId: 'static,
    {
        let mut tex = self.0.borrow_mut();
        let format = texture.format();
        if format != tex.format && !tex.textures.is_empty() {
            warn!(has = ?tex.format, got = ?format, "Multi-SubTexture with wrong format!");
            return;
        }
        tex.format = format;

        trace!(
            "Inserting into: {:p} for {:?}: {:?}",
            self.0.as_ptr(),
            render,
            tex
        );
        let textures = tex.textures.entry(TypeId::of::<A>()).or_default();
        textures.insert(
            render,
            GpuSingleTexture {
                mapping: None,
                texture: Some(Box::new(texture) as Box<_>),
            },
        );
    }

    fn insert_mapping<
        R: GraphicsApi + 'static,
        T: GraphicsApi + 'static,
        I: Iterator<
            Item = (
                Rectangle<i32, BufferCoords>,
                <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping,
            ),
        >,
    >(
        &mut self,
        source: DrmNode,
        render: DrmNode,
        size: Size<i32, BufferCoords>,
        new_mappings: I,
    ) where
        <T::Device as ApiDevice>::Renderer: ExportMem,
        <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    {
        let mut tex_ref = self.0.borrow_mut();
        let tex = &mut *tex_ref;

        let textures = tex.textures.entry(TypeId::of::<R>()).or_default();
        let (old_texture, old_mapping) = textures
            .remove(&render)
            .map(|single| (single.texture, single.mapping))
            .unwrap_or((None, None));
        let old_texture = old_texture.filter(|tex| {
            <dyn Any>::downcast_ref::<<<R::Device as ApiDevice>::Renderer as Renderer>::TextureId>(tex)
                .map(|tex| tex.size())
                == Some(size)
        });

        let mut mappings = old_mapping
            .filter(|(old_src, _)| *old_src == source)
            .map(|(_, mappings)| mappings)
            .unwrap_or_default();

        // don't keep old mappings that are superseeded by new ones
        let format = tex.format;
        let new_mappings = new_mappings
            .filter(|(_, mapping)| {
                let mapping_fmt = TextureMapping::format(mapping);
                if old_texture.is_some() && Some(mapping_fmt) != format {
                    warn!(has = ?format, got = ?mapping_fmt, "Multi-SubTexture Mapping with wrong format!");
                    false
                } else {
                    true
                }
            })
            .map(|(r, m)| (r, Box::new(m) as Box<_>))
            .collect::<Vec<_>>();
        mappings.retain(|(region, _)| {
            !new_mappings
                .iter()
                .any(|(new_region, _)| new_region.contains_rect(*region))
        });
        mappings.extend(new_mappings);

        textures.insert(
            render,
            GpuSingleTexture {
                mapping: Some((source, mappings)),
                texture: old_texture,
            },
        );
    }
}

impl Texture for MultiTexture {
    fn size(&self) -> Size<i32, BufferCoords> {
        self.0.borrow().size
    }
    fn width(&self) -> u32 {
        self.0.borrow().size.w as u32
    }
    fn height(&self) -> u32 {
        self.0.borrow().size.h as u32
    }
    fn format(&self) -> Option<Fourcc> {
        self.0.borrow().format
    }
}

impl<'render, 'target, 'alloc, 'frame, 'color, R: GraphicsApi, T: GraphicsApi, C> Frame<C>
    for MultiFrame<'render, 'target, 'alloc, 'frame, 'color, R, T, C>
where
    C: CMS + 'static,
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    type TextureId = MultiTexture;
    type Error = Error<R, T>;

    fn id(&self) -> usize {
        self.frame.as_ref().unwrap().id()
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, input_profile))]
    fn clear(
        &mut self,
        color: [f32; 4],
        at: &[Rectangle<i32, Physical>],
        input_profile: &C::ColorProfile,
    ) -> Result<(), Error<R, T>> {
        self.damage.extend(at);
        self.frame
            .as_mut()
            .unwrap()
            .clear(color, at, input_profile)
            .map_err(Error::Render)
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, input_profile))]
    fn draw_solid(
        &mut self,
        dst: Rectangle<i32, Physical>,
        damage: &[Rectangle<i32, Physical>],
        color: [f32; 4],
        input_profile: &C::ColorProfile,
    ) -> Result<(), Self::Error> {
        self.damage.extend(damage.iter().copied().map(|mut rect| {
            rect.loc += dst.loc;
            rect
        }));
        self.frame
            .as_mut()
            .unwrap()
            .draw_solid(dst, damage, color, input_profile)
            .map_err(Error::Render)
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, input_profile))]
    fn render_texture_from_to(
        &mut self,
        texture: &MultiTexture,
        src: Rectangle<f64, BufferCoords>,
        dst: Rectangle<i32, Physical>,
        damage: &[Rectangle<i32, Physical>],
        src_transform: Transform,
        alpha: f32,
        input_profile: &C::ColorProfile,
    ) -> Result<(), Error<R, T>> {
        if let Some(texture) = texture.get::<R>(&self.node) {
            self.damage.extend(damage.iter().copied().map(|mut rect| {
                rect.loc += dst.loc;
                rect
            }));
            self.frame
                .as_mut()
                .unwrap()
                .render_texture_from_to(&texture, src, dst, damage, src_transform, alpha, input_profile)
                .map_err(Error::Render)
        } else {
            warn!(
                "Failed to render texture {:?}, import for wrong devices {:?}? {:?}",
                texture.0.as_ptr(),
                self.node,
                texture.0.borrow(),
            );
            Ok(())
        }
    }

    fn transformation(&self) -> Transform {
        self.frame.as_ref().unwrap().transformation()
    }

    fn finish(mut self) -> Result<(), Self::Error> {
        self.finish_internal()
    }
}

#[cfg(feature = "wayland_frontend")]
impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> ImportMemWl
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: ImportMemWl,
    // We need this because the Renderer-impl does and ImportMem requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn import_shm_buffer(
        &mut self,
        buffer: &wl_buffer::WlBuffer,
        surface: Option<&crate::wayland::compositor::SurfaceData>,
        damage: &[Rectangle<i32, BufferCoords>],
    ) -> Result<<Self as Renderer>::TextureId, <Self as Renderer>::Error> {
        let shm_texture = self
            .render
            .renderer_mut()
            .import_shm_buffer(buffer, surface, damage)
            .expect("import_shm_buffer without checking buffer type?");
        let dimensions = shm::with_buffer_contents(buffer, |_, _, data| (data.width, data.height).into())
            .map_err(|_| Error::ImportFailed)?;
        let mut texture = MultiTexture::from_surface(surface, dimensions);
        texture.insert_texture::<R>(*self.render.node(), shm_texture);
        Ok(texture)
    }

    fn shm_formats(&self) -> Box<dyn Iterator<Item = wl_shm::Format>> {
        ImportMemWl::shm_formats(self.render.renderer())
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> ImportMem
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: ImportMem,
    // We need this because the Renderer-impl does and ImportMem requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self, data))]
    fn import_memory(
        &mut self,
        data: &[u8],
        format: Fourcc,
        size: Size<i32, BufferCoords>,
        flipped: bool,
    ) -> Result<<Self as Renderer>::TextureId, <Self as Renderer>::Error> {
        let mem_texture = self
            .render
            .renderer_mut()
            .import_memory(data, format, size, flipped)
            .map_err(Error::Render)?;
        let mut texture = MultiTexture::new(size);
        texture.insert_texture::<R>(*self.render.node(), mem_texture);
        Ok(texture)
    }

    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn update_memory(
        &mut self,
        texture: &<Self as Renderer>::TextureId,
        data: &[u8],
        region: Rectangle<i32, BufferCoords>,
    ) -> Result<(), <Self as Renderer>::Error> {
        let mem_texture = texture
            .get::<R>(self.render.node())
            .ok_or_else(|| Error::MismatchedDevice(*self.render.node()))?;
        self.render
            .renderer_mut()
            .update_memory(&mem_texture, data, region)
            .map_err(Error::Render)
    }

    fn mem_formats(&self) -> Box<dyn Iterator<Item = Fourcc>> {
        ImportMem::mem_formats(self.render.renderer())
    }
}

#[cfg(feature = "wayland_frontend")]
impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> ImportDmaWl
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: ImportDmaWl + ImportMem + ExportMem,
    <T::Device as ApiDevice>::Renderer: ExportMem,
    <<R::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    T: 'static,
    // We need this because the Renderer-impl does and ImportDma requires Renderer
    R: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn import_dma_buffer(
        &mut self,
        buffer: &wl_buffer::WlBuffer,
        surface: Option<&SurfaceData>,
        damage: &[Rectangle<i32, BufferCoords>],
    ) -> Result<<Self as Renderer>::TextureId, <Self as Renderer>::Error> {
        let dmabuf = get_dmabuf(buffer).expect("import_dma_buffer without checking buffer type?");
        let texture = MultiTexture::from_surface(surface, dmabuf.size());
        let texture_ref = texture.0.clone();
        let res = self.import_dmabuf_internal(None, &dmabuf, texture, Some(damage));
        if res.is_ok() {
            if let Some(surface) = surface {
                surface.data_map.insert_if_missing(|| texture_ref);
            }
        }
        res
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> ImportDma
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: ImportDma + ImportMem + ExportMem,
    <T::Device as ApiDevice>::Renderer: ExportMem,
    <<R::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    T: 'static,
    // We need this because the Renderer-impl does and ImportDma requires Renderer
    R: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn dmabuf_formats(&self) -> Box<dyn Iterator<Item = Format>> {
        ImportDma::dmabuf_formats(self.render.renderer())
    }

    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn import_dmabuf(
        &mut self,
        dmabuf: &Dmabuf,
        damage: Option<&[Rectangle<i32, BufferCoords>]>,
    ) -> Result<<Self as Renderer>::TextureId, <Self as Renderer>::Error> {
        let texture = MultiTexture::new(dmabuf.size());
        self.import_dmabuf_internal(None, dmabuf, texture, damage)
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: ImportDma + ImportMem + ExportMem,
    <T::Device as ApiDevice>::Renderer: ExportMem,
    <<R::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: 'static,
    T: 'static,
    // We need this because the Renderer-impl does and ImportDma requires Renderer
    R: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    fn import_missing(
        &mut self,
        new_damage: Vec<Rectangle<i32, BufferCoords>>,
        source: Option<DrmNode>,
        dmabuf: &Dmabuf,
        texture: &mut MultiTexture,
    ) -> Result<(), <Self as Renderer>::Error> {
        if let Some(import_renderer) = self.target.as_mut().filter(|target| match source {
            Some(s) => &s == target.device.node(),
            None => true,
        }) {
            if let Ok(dma_texture) = import_renderer
                .device
                .renderer_mut()
                .import_dmabuf(dmabuf, Some(&*new_damage))
            {
                let format = dma_texture
                    .format()
                    // Check the target device supports the format, if not use 8-bit format
                    .filter(|format| self.render.renderer().mem_formats().any(|fmt| fmt == *format))
                    // The GL spec *always* supports this format.
                    // TODO: Re-evaluate this, once we support vulkan
                    .unwrap_or(Fourcc::Abgr8888);

                let mappings = new_damage
                    .into_iter()
                    .map(|damage| {
                        let mapping = import_renderer
                            .device
                            .renderer_mut()
                            .copy_texture(&dma_texture, damage, format)
                            .map_err(Error::Target)?;
                        debug!("Creating mapping for: {:?}", damage);
                        Ok((damage, mapping))
                    })
                    .collect::<Result<Vec<_>, Error<R, T>>>()?;
                texture.insert_mapping::<R, T, _>(
                    *import_renderer.device.node(),
                    *self.render.node(),
                    dma_texture.size(),
                    mappings.into_iter(),
                );
                return Ok(());
            }
        }

        let (first, last) = match source {
            Some(s) => self
                .other_renderers
                .iter_mut()
                .partition::<Vec<_>, _>(|other| other.node() == &s),
            None => (Vec::new(), self.other_renderers.iter_mut().collect()),
        };
        for import_renderer in first.into_iter().chain(last.into_iter()) {
            if let Ok(dma_texture) =
                ImportDma::import_dmabuf(import_renderer.renderer_mut(), dmabuf, Some(&*new_damage))
            {
                let format = dma_texture
                    .format()
                    // Check the target device supports the format, if not use 8-bit format
                    .filter(|format| self.render.renderer().mem_formats().any(|fmt| fmt == *format))
                    // The GL spec *always* supports this format.
                    // TODO: Re-evaluate this, once we support vulkan
                    .unwrap_or(Fourcc::Abgr8888);

                let mappings = new_damage
                    .into_iter()
                    .map(|damage| {
                        let mapping = ExportMem::copy_texture(
                            import_renderer.renderer_mut(),
                            &dma_texture,
                            damage,
                            format,
                        )
                        .map_err(Error::Render)?;
                        Ok((damage, mapping))
                    })
                    .collect::<Result<Vec<_>, Error<R, T>>>()?;
                texture.insert_mapping::<R, R, _>(
                    *import_renderer.node(),
                    *self.render.node(),
                    texture.size(),
                    mappings.into_iter(),
                );
                return Ok(());
            }
        }

        Err(Error::ImportFailed)
    }

    fn import_dmabuf_internal(
        &mut self,
        source: Option<DrmNode>,
        dmabuf: &Dmabuf,
        mut texture: MultiTexture,
        damage: Option<&[Rectangle<i32, BufferCoords>]>,
    ) -> Result<<Self as Renderer>::TextureId, <Self as Renderer>::Error> {
        let format = dmabuf.format();
        if ImportDma::dmabuf_formats(self.render.renderer()).any(|f| f == format) {
            match self.render.renderer_mut().import_dmabuf(dmabuf, damage) {
                Ok(imported) => {
                    texture.insert_texture::<R>(*self.render.node(), imported);
                    return Ok(texture);
                }
                Err(err) => {
                    trace!(
                        "Error importing dmabuf (format: {:?}) to {}: {}",
                        dmabuf.format(),
                        self.render.node(),
                        err
                    );
                    trace!("Falling back to cpu-copy.");
                }
            }
        }

        let damage = damage.map(|damage| {
            damage
                .iter()
                .flat_map(|rect| rect.intersection(Rectangle::from_loc_and_size((0, 0), dmabuf.size())))
                .fold(Vec::<Rectangle<i32, BufferCoords>>::new(), |damage, mut rect| {
                    // replace with drain_filter, when that becomes stable to reuse the original Vec's memory
                    let (overlapping, mut new_damage): (Vec<_>, Vec<_>) = damage
                        .into_iter()
                        .partition(|other| other.overlaps_or_touches(rect));

                    for overlap in overlapping {
                        rect = rect.merge(overlap);
                    }
                    new_damage.push(rect);
                    new_damage
                })
        });

        let render_node = self.render.node();
        // lets check if we don't have a mapping
        let size = texture.0.borrow().size;
        let new_damage = texture
            .0
            .borrow_mut()
            .textures
            .get_mut(&TypeId::of::<R>())
            .and_then(|nodes_textures| nodes_textures.get_mut(render_node))
            .map(|texture| match texture.mapping.as_ref() {
                None => vec![Rectangle::from_loc_and_size((0, 0), size)],
                // in the few cases, were we need to rerender more, than was damaged by the client,
                // we might have not been continuously rendering this buffer. So we need to assume,
                // everything might have been damaged in the meantime.
                // In those cases we cannot assume that our existing texture + early-import is sufficiently
                // recent and we need to reimport.
                Some((_, mappings)) => damage
                    .as_ref()
                    .filter(|_| texture.texture.is_some()) // we need a full import in that case
                    .cloned()
                    .unwrap_or_else(|| vec![Rectangle::from_loc_and_size((0, 0), size)])
                    .into_iter()
                    .filter(|rect| !mappings.iter().any(|(region, _)| region.contains_rect(*rect)))
                    .collect(),
            })
            .unwrap_or_else(|| vec![Rectangle::from_loc_and_size((0, 0), size)]);

        trace!(
            "Copying dmabuf {:?} from {:?} to {:?} for {:?}: {:?}",
            dmabuf.handles().collect::<Vec<_>>(),
            source,
            render_node,
            texture.0.as_ptr(),
            texture.0.borrow(),
        );
        if !new_damage.is_empty() {
            // no (complete) early-import :(
            trace!("Missing damage {:?}: {:?}", texture.0.as_ptr(), new_damage);
            self.import_missing(new_damage, source, dmabuf, &mut texture)?;
        }
        // else we have an early import(!)

        let mut texture_ref = texture.0.borrow_mut();
        let tex = texture_ref
            .textures
            .get_mut(&TypeId::of::<R>())
            .unwrap()
            .get_mut(self.render.node())
            .unwrap();
        let (foreign_node, mappings) = tex.mapping.take().unwrap();
        if tex.texture.is_none() {
            // full upload
            let new_texture = if let Some(source) = self
                .target
                .as_mut()
                .filter(|target| target.device.node() == &foreign_node)
            {
                assert!(mappings[0].0.loc == (0, 0).into());
                assert!(mappings[0].0.size == size);
                let mapping = <dyn Any>::downcast_ref::<
                    <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping,
                >(&*mappings[0].1)
                .unwrap();

                trace!("Importing mapping as full buffer {:?}", mapping.size());
                let mapped = source
                    .device
                    .renderer_mut()
                    .map_texture(mapping)
                    .map_err(Error::Target)?;
                Some(
                    ImportMem::import_memory(
                        self.render.renderer_mut(),
                        mapped,
                        TextureMapping::format(mapping),
                        mapping.size(),
                        false,
                    )
                    .map_err(Error::Render)?,
                )
            } else if let Some(source) = self
                .other_renderers
                .iter_mut()
                .find(|device| device.node() == &foreign_node)
            {
                assert!(mappings[0].0.loc == (0, 0).into());
                assert!(mappings[0].0.size == size);
                let mapping = <dyn Any>::downcast_ref::<
                    <<R::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping,
                >(&*mappings[0].1)
                .unwrap();

                trace!("Importing mapping as full buffer {:?}", mapping.size());
                let mapped = ExportMem::map_texture(source.renderer_mut(), mapping).map_err(Error::Render)?;
                Some(
                    self.render
                        .renderer_mut()
                        .import_memory(mapped, TextureMapping::format(mapping), mapping.size(), false)
                        .map_err(Error::Render)?,
                )
            } else {
                warn!("Failed to find device for importing: {:?}", dmabuf);
                None
            };
            if let Some(new_texture) = new_texture {
                tex.texture = Some(Box::new(new_texture) as Box<_>);
            }
        } else {
            // update
            let texture = <dyn Any>::downcast_ref::<
                <<R::Device as ApiDevice>::Renderer as Renderer>::TextureId,
            >(tex.texture.as_ref().unwrap())
            .unwrap();
            if let Some(source) = self
                .target
                .as_mut()
                .filter(|target| target.device.node() == &foreign_node)
            {
                for (region, mapping) in mappings {
                    let mapping = <dyn Any>::downcast_ref::<
                        <<T::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping,
                    >(&*mapping)
                    .unwrap();
                    trace!(
                        "Updating texture {:?} with mapping at {:?}",
                        texture.size(),
                        region
                    );
                    let mapped = source
                        .device
                        .renderer_mut()
                        .map_texture(mapping)
                        .map_err(Error::Target)?;
                    self.render
                        .renderer_mut()
                        .update_memory(texture, mapped, region)
                        .map_err(Error::Render)?;
                }
            } else if let Some(source) = self
                .other_renderers
                .iter_mut()
                .find(|device| device.node() == &foreign_node)
            {
                for (region, mapping) in mappings {
                    let mapping = <dyn Any>::downcast_ref::<
                        <<R::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping,
                    >(&*mapping)
                    .unwrap();
                    trace!(
                        "Updating texture {:?} with mapping at {:?}",
                        texture.size(),
                        region
                    );
                    let mapped =
                        ExportMem::map_texture(source.renderer_mut(), mapping).map_err(Error::Render)?;
                    self.render
                        .renderer_mut()
                        .update_memory(texture, mapped, region)
                        .map_err(Error::Render)?;
                }
            } else {
                warn!("Failed to find device for updating: {:?}", dmabuf);
            };
        }
        std::mem::drop(texture_ref);
        Ok(texture)
    }
}

/// [`TextureMapping`](super::TextureMapping)s produced by [`ExportMem`]-implementations of
/// [`MultiRenderer`]s.
pub struct MultiTextureMapping<A: GraphicsApi, B: GraphicsApi>(TextureMappingInternal<A, B>)
where
    <A::Device as ApiDevice>::Renderer: ExportMem,
    <B::Device as ApiDevice>::Renderer: ExportMem;
enum TextureMappingInternal<A: GraphicsApi, B: GraphicsApi>
where
    <A::Device as ApiDevice>::Renderer: ExportMem,
    <B::Device as ApiDevice>::Renderer: ExportMem,
{
    Either(<<A::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping),
    Or(<<B::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping),
}
impl<A: GraphicsApi, B: GraphicsApi> fmt::Debug for MultiTextureMapping<A, B>
where
    <A::Device as ApiDevice>::Renderer: ExportMem,
    <B::Device as ApiDevice>::Renderer: ExportMem,
    <<A::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: fmt::Debug,
    <<B::Device as ApiDevice>::Renderer as ExportMem>::TextureMapping: fmt::Debug,
{
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.0 {
            TextureMappingInternal::Either(ref mapping) => mapping.fmt(f),
            TextureMappingInternal::Or(ref mapping) => mapping.fmt(f),
        }
    }
}

impl<A: GraphicsApi, B: GraphicsApi> Texture for MultiTextureMapping<A, B>
where
    <A::Device as ApiDevice>::Renderer: ExportMem,
    <B::Device as ApiDevice>::Renderer: ExportMem,
{
    fn size(&self) -> Size<i32, BufferCoords> {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => x.size(),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => x.size(),
        }
    }

    fn width(&self) -> u32 {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => x.width(),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => x.width(),
        }
    }
    fn height(&self) -> u32 {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => x.height(),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => x.height(),
        }
    }
    fn format(&self) -> Option<Fourcc> {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => Texture::format(x),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => Texture::format(x),
        }
    }
}
impl<A: GraphicsApi, B: GraphicsApi> TextureMapping for MultiTextureMapping<A, B>
where
    <A::Device as ApiDevice>::Renderer: ExportMem,
    <B::Device as ApiDevice>::Renderer: ExportMem,
{
    fn flipped(&self) -> bool {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => x.flipped(),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => x.flipped(),
        }
    }

    fn format(&self) -> Fourcc {
        match self {
            MultiTextureMapping::<A, B>(TextureMappingInternal::Either(x)) => TextureMapping::format(x),
            MultiTextureMapping::<A, B>(TextureMappingInternal::Or(x)) => TextureMapping::format(x),
        }
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi> ExportMem
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <T::Device as ApiDevice>::Renderer: ExportMem,
    <R::Device as ApiDevice>::Renderer: ExportMem,
    // We need this because the Renderer-impl does and ExportMem requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    type TextureMapping = MultiTextureMapping<T, R>;

    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn copy_framebuffer(
        &mut self,
        region: Rectangle<i32, BufferCoords>,
        format: Fourcc,
    ) -> Result<Self::TextureMapping, <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target
                .device
                .renderer_mut()
                .copy_framebuffer(region, format)
                .map(|mapping| MultiTextureMapping(TextureMappingInternal::Either(mapping)))
                .map_err(Error::Target)
        } else {
            self.render
                .renderer_mut()
                .copy_framebuffer(region, format)
                .map(|mapping| MultiTextureMapping(TextureMappingInternal::Or(mapping)))
                .map_err(Error::Render)
        }
    }

    #[instrument(level = "trace", parent = &self.span, skip(self))]
    fn copy_texture(
        &mut self,
        texture: &Self::TextureId,
        region: Rectangle<i32, BufferCoords>,
        format: Fourcc,
    ) -> Result<Self::TextureMapping, Self::Error> {
        let tex = texture
            .get::<R>(self.render.node())
            .ok_or_else(|| Error::MismatchedDevice(*self.render.node()))?;
        self.render
            .renderer_mut()
            .copy_texture(&tex, region, format)
            .map(|mapping| MultiTextureMapping(TextureMappingInternal::Or(mapping)))
            .map_err(Error::Render)
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, texture_mapping))]
    fn map_texture<'c>(
        &mut self,
        texture_mapping: &'c Self::TextureMapping,
    ) -> Result<&'c [u8], <Self as Renderer>::Error> {
        match texture_mapping {
            MultiTextureMapping(TextureMappingInternal::Either(target_mapping)) => self
                .target
                .as_mut()
                .unwrap()
                .device
                .renderer_mut()
                .map_texture(target_mapping)
                .map_err(Error::Target),
            MultiTextureMapping(TextureMappingInternal::Or(render_mapping)) => self
                .render
                .renderer_mut()
                .map_texture(render_mapping)
                .map_err(Error::Render),
        }
    }
}

impl<'render, 'target, 'alloc, R: GraphicsApi, T: GraphicsApi, BlitTarget> Blit<BlitTarget>
    for MultiRenderer<'render, 'target, 'alloc, R, T>
where
    <R::Device as ApiDevice>::Renderer: Blit<BlitTarget> + Bind<BlitTarget>,
    <T::Device as ApiDevice>::Renderer: Blit<BlitTarget> + Bind<BlitTarget>,
    // We need this because the Renderer-impl does and Blit requires Renderer
    R: 'static,
    R::Error: 'static,
    T::Error: 'static,
    <R::Device as ApiDevice>::Renderer: Bind<Dmabuf> + ExportMem + ImportDma + ImportMem,
    <T::Device as ApiDevice>::Renderer: ImportDma + ImportMem,
    <<R::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
    <<T::Device as ApiDevice>::Renderer as Renderer>::Error: 'static,
{
    #[instrument(level = "trace", parent = &self.span, skip(self, to))]
    fn blit_to(
        &mut self,
        to: BlitTarget,
        src: Rectangle<i32, Physical>,
        dst: Rectangle<i32, Physical>,
        filter: TextureFilter,
    ) -> Result<(), <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target
                .device
                .renderer_mut()
                .blit_to(to, src, dst, filter)
                .map_err(Error::Target)
        } else {
            self.render
                .renderer_mut()
                .blit_to(to, src, dst, filter)
                .map_err(Error::Render)
        }
    }

    #[instrument(level = "trace", parent = &self.span, skip(self, from))]
    fn blit_from(
        &mut self,
        from: BlitTarget,
        src: Rectangle<i32, Physical>,
        dst: Rectangle<i32, Physical>,
        filter: TextureFilter,
    ) -> Result<(), <Self as Renderer>::Error> {
        if let Some(target) = self.target.as_mut() {
            target
                .device
                .renderer_mut()
                .blit_from(from, src, dst, filter)
                .map_err(Error::Target)
        } else {
            self.render
                .renderer_mut()
                .blit_from(from, src, dst, filter)
                .map_err(Error::Render)
        }
    }
}
